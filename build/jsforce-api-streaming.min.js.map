{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","lib/api/streaming.js","jsforce-api-streaming.min.js","node_modules/browserify/node_modules/process/browser.js","node_modules/faye/browser/faye-browser.js"],"names":["f","exports","module","define","amd","g","window","global","self","this","jsforce","modules","api","Streaming","e","t","n","r","s","o","u","a","require","i","Error","code","l","call","length",1,"events","inherits","_","Faye","Topic","streaming","name","_streaming","prototype","subscribe","listener","unsubscribe","Channel","_name","push","callback","isArray","conn","_conn","_id","sobject","findOne","Name","then","rec","Id","id","channelUrl","requestPost","pushEvents","rets","thenCall","EventEmitter","_createClient","endpointUrl","instanceUrl","version","join","fayeClient","Client","setHeader","accessToken","topic","_topics","channel","channelId","_fayeClient","Transport","NodeHttp","batching","channelName","indexOf","on","faye",2,"cleanUpNextTick","draining","currentQueue","queue","concat","queueIndex","drainQueue","timeout","setTimeout","len","run","clearTimeout","Item","fun","array","noop","process","nextTick","args","Array","arguments","apply","title","browser","env","argv","versions","addListener","once","off","removeListener","removeAllListeners","emit","binding","cwd","chdir","dir","umask",3,"VERSION","BAYEUX_VERSION","ID_LENGTH","JSONP_CALLBACK","CONNECTION_TYPES","MANDATORY_CONNECTION_TYPES","ENV","extend","dest","source","overwrite","key","hasOwnProperty","random","bitlength","maxLength","Math","ceil","log","string","csprng","validateOptions","options","validKeys","clientIdFromMessages","messages","connect","filter","message","clientId","copyObject","object","clone","commonElement","lista","listb","list","needle","map","context","result","asyncEach","iterator","calls","looping","iterate","resume","loop","toJSON","stringify","value","JSON","Class","parent","methods","Object","klass","initialize","bridge","xs","x","toString","type","_events","error","handler","slice","listeners","splice","Namespace","_used","exists","generate","release","defer","setImmediate","fn","PENDING","FULFILLED","REJECTED","RETURN","THROW","Promise","task","_state","_onFulfilled","_onRejected","fulfill","reason","reject","onFulfilled","onRejected","next","registerOnFulfilled","registerOnRejected","promise","invoke","_value","_reason","_invoke","outcome","TypeError","resolve","called","_fulfill","v","shift","all","promises","fulfilled","deferred","pending","tuple","resolved","rejected","Set","_index","add","item","undefined","forEach","block","isEmpty","member","remove","removed","toArray","URI","isURI","uri","protocol","host","path","isSameOrigin","location","hostname","port","parse","url","parts","query","pairs","data","consume","pattern","replace","match","test","pathname","substr","split","search","decodeURIComponent","href","queryString","hash","encodeURIComponent","params","Grammar","ERROR","parseInt","versionMismatch","conntypeMismatch","extMismatch","badRequest","clientUnknown","parameterMissing","channelForbidden","channelUnknown","channelInvalid","extUnknown","publishFailed","serverError","Deferrable","errback","_promise","_reject","seconds","_timer","setDeferredStatus","status","Publisher","countListeners","eventType","bind","_listeners","unbind","trigger","Timeouts","addTimeout","delay","_timeouts","removeTimeout","removeAllTimeouts","Logging","LOG_LEVELS","fatal","warn","info","debug","writeLog","messageArgs","level","logger","banner","className","CHANNEL_NAME","CHANNEL_PATTERN","Extensible","addExtension","extension","_extensions","added","removeExtension","pipeThroughExtensions","stage","request","extensions","pipe","isUnused","HANDSHAKE","CONNECT","SUBSCRIBE","UNSUBSCRIBE","DISCONNECT","META","SERVICE","expand","segments","channels","copy","unparse","isValid","isMeta","isService","isSubscribable","_channels","getKeys","keys","hasSubscription","names","distributeMessage","Publication","Subscription","client","_client","_callback","_context","_cancelled","cancel","UNCONNECTED","CONNECTING","CONNECTED","DISCONNECTED","RETRY","NONE","CONNECTION_TIMEOUT","DEFAULT_ENDPOINT","INTERVAL","endpoint","_endpoint","_dispatcher","Dispatcher","_messageId","_responseCallbacks","_advice","reconnect","interval","_receiveMessage","Event","onbeforeunload","_disabled","disconnect","addWebsocketExtension","disable","feature","handshake","selectTransport","_sendMessage","supportedConnectionTypes","getConnectionTypes","response","successful","retry","_connectRequest","connectionType","_cycleConnection","close","c","subscription","force","hasSubscribe","dead","publish","publication","_generateMessageId","sendMessage","pow","advice","_handleAdvice","_deliverMessage","MAX_REQUEST_SIZE","DEFAULT_RETRY","UP","DOWN","_alternates","endpoints","cookies","Cookies","CookieJar","_envelopes","headers","_scheduler","scheduler","Scheduler","transports","wsExtensions","proxy","_proxy","origin","exts","websocketExtensions","tls","ca","maxRequestSize","endpointFor","transport","_transport","transportTypes","get","attempts","deadline","Date","getTime","envelope","_sendEnvelope","timer","isDeliverable","abort","handleError","getTimeout","send","handleResponse","reply","succeed","immediate","req","fail","getInterval","made","now","DEFAULT_PORTS","http:","https:","ws:","wss:","SECURE_PROTOCOLS","MAX_DELAY","dispatcher","_outbox","NodeAdapter","HTTPS_PROXY","https_proxy","HTTP_PROXY","http_proxy","encode","_flushLargeBatch","_flush","_connectMessage","last","pop","_receive","replies","_handleError","_getCookies","getCookiesSync","cookie","cookieString","_storeCookies","setCookie","Cookie","setCookieSync","allowed","disabled","_transports","pair","connType","connEndpoint","isUsable","create","register","_registry","element","eventName","wrapped","addEventListener","attachEvent","_element","_type","_handler","detach","removeEventListener","detachEvent","onunload","quote","escapable","lastIndex","meta","charCodeAt","str","holder","k","partial","mind","gap","rep","isFinite","String","indent","valueOf","getUTCFullYear","getUTCMonth","getUTCDate","getUTCHours","getUTCMinutes","getUTCSeconds","Number","Boolean","cx","\b","\t","\n","\f","\r","\"","\\","replacer","space","","text","reviver","walk","j","eval","SyntaxError","WebSocket","_pending","socket","readyState","ws","_unloaded","_createSocket","onopen","_socket","_everConnected","_ping","closed","onclose","onerror","wasConnected","onmessage","event","getSocketUrl","MozWebSocket","PROTOCOLS","sockets","websocket","EventSource","_xhr","XHR","usable","eventsource","xhr","ActiveXObject","XMLHttpRequest","open","setRequestHeader","onreadystatechange","responseText","CORS","xhrClass","XDomainRequest","cleanUp","onload","ontimeout","onprogress","withCredentials","JSONP","jsonp","_cbCount","head","document","getElementsByTagName","script","createElement","callbackName","getCallbackName","cleanup","parentNode","removeChild","src","appendChild","_process"],"mappings":"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","file":"jsforce-api-streaming.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","/**\n * @file Manages Streaming APIs\n * @author Shinichi Tomita <shinichi.tomita@gmail.com>\n */\n\n'use strict';\n\nvar events = window.jsforce.require('events'),\n    inherits = window.jsforce.require('inherits'),\n    _ = window.jsforce.require('lodash/core'),\n    Faye   = require('faye'),\n    jsforce = window.jsforce.require('./core');\n\n/**\n * Streaming API topic class\n *\n * @class Streaming~Topic\n * @param {Streaming} steaming - Streaming API object\n * @param {String} name - Topic name\n */\nvar Topic = function(streaming, name) {\n  this._streaming = streaming;\n  this.name = name;\n};\n\n/**\n * @typedef {Object} Streaming~StreamingMessage\n * @prop {Object} event\n * @prop {Object} event.type - Event type\n * @prop {Record} sobject - Record information\n */\n/**\n * Subscribe listener to topic\n *\n * @method Streaming~Topic#subscribe\n * @param {Callback.<Streaming~StreamingMesasge>} listener - Streaming message listener\n * @returns {Subscription} - Faye subscription object\n */\nTopic.prototype.subscribe = function(listener) {\n  return this._streaming.subscribe(this.name, listener);\n};\n\n/**\n * Unsubscribe listener from topic\n *\n * @method Streaming~Topic#unsubscribe\n * @param {Callback.<Streaming~StreamingMesasge>} listener - Streaming message listener\n * @returns {Streaming~Topic}\n */\nTopic.prototype.unsubscribe = function(listener) {\n  this._streaming.unsubscribe(this.name, listener);\n  return this;\n};\n\n/*--------------------------------------------*/\n\n/**\n * Streaming API Generic Streaming Channel\n *\n * @class Streaming~Channel\n * @param {Streaming} steaming - Streaming API object\n * @param {String} name - Channel name (starts with \"/u/\")\n */\nvar Channel = function(streaming, name) {\n  this._streaming = streaming;\n  this._name = name;\n};\n\n/**\n * Subscribe to hannel\n *\n * @param {Callback.<Streaming~StreamingMessage>} listener - Streaming message listener\n * @returns {Subscription} - Faye subscription object\n */\nChannel.prototype.subscribe = function(listener) {\n  return this._streaming.subscribe(this._name, listener);\n};\n\nChannel.prototype.unsubscribe = function(listener) {\n  this._streaming.unsubscribe(this._name, listener);\n  return this;\n};\n\nChannel.prototype.push = function(events, callback) {\n  var isArray = _.isArray(events);\n  events = isArray ? events : [ events ];\n  var conn = this._streaming._conn;\n  if (!this._id) {\n    this._id = conn.sobject('StreamingChannel').findOne({ Name: this._name }, 'Id')\n      .then(function(rec) { return rec.Id });\n  }\n  return this._id.then(function(id) {\n    var channelUrl = '/sobjects/StreamingChannel/' + id + '/push';\n    return conn.requestPost(channelUrl, { pushEvents: events });\n  }).then(function(rets) {\n    return isArray ? rets : rets[0];\n  }).thenCall(callback);\n};\n\n/*--------------------------------------------*/\n\n/**\n * Streaming API class\n *\n * @class\n * @extends events.EventEmitter\n * @param {Connection} conn - Connection object\n */\nvar Streaming = function(conn) {\n  this._conn = conn;\n};\n\ninherits(Streaming, events.EventEmitter);\n\n/** @private **/\nStreaming.prototype._createClient = function() {\n  var endpointUrl = [ this._conn.instanceUrl, \"cometd\", this._conn.version ].join('/');\n  var fayeClient = new Faye.Client(endpointUrl, {});\n  fayeClient.setHeader('Authorization', 'OAuth '+this._conn.accessToken);\n  return fayeClient;\n};\n\n/**\n * Get named topic\n *\n * @param {String} name - Topic name\n * @returns {Streaming~Topic}\n */\nStreaming.prototype.topic = function(name) {\n  this._topics = this._topics || {};\n  var topic = this._topics[name] =\n    this._topics[name] || new Topic(this, name);\n  return topic;\n};\n\n/**\n * Get Channel for Id\n * @param {String} channelId - Id of StreamingChannel object\n * @returns {Streaming~Channel}\n */\nStreaming.prototype.channel = function(channelId) {\n  return new Channel(this, channelId);\n};\n\n/**\n * Subscribe topic/channel\n *\n * @param {String} name - Topic name\n * @param {Callback.<Streaming~StreamingMessage>} listener - Streaming message listener\n * @returns {Subscription} - Faye subscription object\n */\nStreaming.prototype.subscribe = function(name, listener) {\n  if (!this._fayeClient) {\n    if (Faye.Transport.NodeHttp) {\n      Faye.Transport.NodeHttp.prototype.batching = false; // prevent streaming API server error\n    }\n    this._fayeClient = this._createClient();\n  }\n  var channelName = name.indexOf('/') === 0 ? name : '/topic/' + name;\n  return this._fayeClient.subscribe(channelName, listener);\n};\n\n/**\n * Unsubscribe topic\n *\n * @param {String} name - Topic name\n * @param {Callback.<Streaming~StreamingMessage>} listener - Streaming message listener\n * @returns {Streaming}\n */\nStreaming.prototype.unsubscribe = function(name, listener) {\n  if (this._fayeClient) {\n    var channelName = name.indexOf('/') === 0 ? name : '/topic/' + name;\n    this._fayeClient.unsubscribe(channelName, listener);\n  }\n  return this;\n};\n\n\n/*--------------------------------------------*/\n/*\n * Register hook in connection instantiation for dynamically adding this API module features\n */\njsforce.on('connection:new', function(conn) {\n  conn.streaming = new Streaming(conn);\n});\n\n\nmodule.exports = Streaming;\n","(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g=(g.jsforce||(g.jsforce = {}));g=(g.modules||(g.modules = {}));g=(g.api||(g.api = {}));g.Streaming = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n/**\n * @file Manages Streaming APIs\n * @author Shinichi Tomita <shinichi.tomita@gmail.com>\n */\n\n'use strict';\n\nvar events = window.jsforce.require('events'),\n    inherits = window.jsforce.require('inherits'),\n    _ = window.jsforce.require('lodash/core'),\n    Faye   = require('faye'),\n    jsforce = window.jsforce.require('./core');\n\n/**\n * Streaming API topic class\n *\n * @class Streaming~Topic\n * @param {Streaming} steaming - Streaming API object\n * @param {String} name - Topic name\n */\nvar Topic = function(streaming, name) {\n  this._streaming = streaming;\n  this.name = name;\n};\n\n/**\n * @typedef {Object} Streaming~StreamingMessage\n * @prop {Object} event\n * @prop {Object} event.type - Event type\n * @prop {Record} sobject - Record information\n */\n/**\n * Subscribe listener to topic\n *\n * @method Streaming~Topic#subscribe\n * @param {Callback.<Streaming~StreamingMesasge>} listener - Streaming message listener\n * @returns {Subscription} - Faye subscription object\n */\nTopic.prototype.subscribe = function(listener) {\n  return this._streaming.subscribe(this.name, listener);\n};\n\n/**\n * Unsubscribe listener from topic\n *\n * @method Streaming~Topic#unsubscribe\n * @param {Callback.<Streaming~StreamingMesasge>} listener - Streaming message listener\n * @returns {Streaming~Topic}\n */\nTopic.prototype.unsubscribe = function(listener) {\n  this._streaming.unsubscribe(this.name, listener);\n  return this;\n};\n\n/*--------------------------------------------*/\n\n/**\n * Streaming API Generic Streaming Channel\n *\n * @class Streaming~Channel\n * @param {Streaming} steaming - Streaming API object\n * @param {String} name - Channel name (starts with \"/u/\")\n */\nvar Channel = function(streaming, name) {\n  this._streaming = streaming;\n  this._name = name;\n};\n\n/**\n * Subscribe to hannel\n *\n * @param {Callback.<Streaming~StreamingMessage>} listener - Streaming message listener\n * @returns {Subscription} - Faye subscription object\n */\nChannel.prototype.subscribe = function(listener) {\n  return this._streaming.subscribe(this._name, listener);\n};\n\nChannel.prototype.unsubscribe = function(listener) {\n  this._streaming.unsubscribe(this._name, listener);\n  return this;\n};\n\nChannel.prototype.push = function(events, callback) {\n  var isArray = _.isArray(events);\n  events = isArray ? events : [ events ];\n  var conn = this._streaming._conn;\n  if (!this._id) {\n    this._id = conn.sobject('StreamingChannel').findOne({ Name: this._name }, 'Id')\n      .then(function(rec) { return rec.Id });\n  }\n  return this._id.then(function(id) {\n    var channelUrl = '/sobjects/StreamingChannel/' + id + '/push';\n    return conn.requestPost(channelUrl, { pushEvents: events });\n  }).then(function(rets) {\n    return isArray ? rets : rets[0];\n  }).thenCall(callback);\n};\n\n/*--------------------------------------------*/\n\n/**\n * Streaming API class\n *\n * @class\n * @extends events.EventEmitter\n * @param {Connection} conn - Connection object\n */\nvar Streaming = function(conn) {\n  this._conn = conn;\n};\n\ninherits(Streaming, events.EventEmitter);\n\n/** @private **/\nStreaming.prototype._createClient = function() {\n  var endpointUrl = [ this._conn.instanceUrl, \"cometd\", this._conn.version ].join('/');\n  var fayeClient = new Faye.Client(endpointUrl, {});\n  fayeClient.setHeader('Authorization', 'OAuth '+this._conn.accessToken);\n  return fayeClient;\n};\n\n/**\n * Get named topic\n *\n * @param {String} name - Topic name\n * @returns {Streaming~Topic}\n */\nStreaming.prototype.topic = function(name) {\n  this._topics = this._topics || {};\n  var topic = this._topics[name] =\n    this._topics[name] || new Topic(this, name);\n  return topic;\n};\n\n/**\n * Get Channel for Id\n * @param {String} channelId - Id of StreamingChannel object\n * @returns {Streaming~Channel}\n */\nStreaming.prototype.channel = function(channelId) {\n  return new Channel(this, channelId);\n};\n\n/**\n * Subscribe topic/channel\n *\n * @param {String} name - Topic name\n * @param {Callback.<Streaming~StreamingMessage>} listener - Streaming message listener\n * @returns {Subscription} - Faye subscription object\n */\nStreaming.prototype.subscribe = function(name, listener) {\n  if (!this._fayeClient) {\n    if (Faye.Transport.NodeHttp) {\n      Faye.Transport.NodeHttp.prototype.batching = false; // prevent streaming API server error\n    }\n    this._fayeClient = this._createClient();\n  }\n  var channelName = name.indexOf('/') === 0 ? name : '/topic/' + name;\n  return this._fayeClient.subscribe(channelName, listener);\n};\n\n/**\n * Unsubscribe topic\n *\n * @param {String} name - Topic name\n * @param {Callback.<Streaming~StreamingMessage>} listener - Streaming message listener\n * @returns {Streaming}\n */\nStreaming.prototype.unsubscribe = function(name, listener) {\n  if (this._fayeClient) {\n    var channelName = name.indexOf('/') === 0 ? name : '/topic/' + name;\n    this._fayeClient.unsubscribe(channelName, listener);\n  }\n  return this;\n};\n\n\n/*--------------------------------------------*/\n/*\n * Register hook in connection instantiation for dynamically adding this API module features\n */\njsforce.on('connection:new', function(conn) {\n  conn.streaming = new Streaming(conn);\n});\n\n\nmodule.exports = Streaming;\n\n},{\"faye\":3}],2:[function(require,module,exports){\n// shim for using process in browser\n\nvar process = module.exports = {};\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = setTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    clearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        setTimeout(drainQueue, 0);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n},{}],3:[function(require,module,exports){\n(function (process,global){\n(function() {\n'use strict';\n\nvar Faye = {\n  VERSION:          '1.1.2',\n\n  BAYEUX_VERSION:   '1.0',\n  ID_LENGTH:        160,\n  JSONP_CALLBACK:   'jsonpcallback',\n  CONNECTION_TYPES: ['long-polling', 'cross-origin-long-polling', 'callback-polling', 'websocket', 'eventsource', 'in-process'],\n\n  MANDATORY_CONNECTION_TYPES: ['long-polling', 'callback-polling', 'in-process'],\n\n  ENV: (typeof window !== 'undefined') ? window : global,\n\n  extend: function(dest, source, overwrite) {\n    if (!source) return dest;\n    for (var key in source) {\n      if (!source.hasOwnProperty(key)) continue;\n      if (dest.hasOwnProperty(key) && overwrite === false) continue;\n      if (dest[key] !== source[key])\n        dest[key] = source[key];\n    }\n    return dest;\n  },\n\n  random: function(bitlength) {\n    bitlength = bitlength || this.ID_LENGTH;\n    var maxLength = Math.ceil(bitlength * Math.log(2) / Math.log(36));\n    var string = csprng(bitlength, 36);\n    while (string.length < maxLength) string = '0' + string;\n    return string;\n  },\n\n  validateOptions: function(options, validKeys) {\n    for (var key in options) {\n      if (this.indexOf(validKeys, key) < 0)\n        throw new Error('Unrecognized option: ' + key);\n    }\n  },\n\n  clientIdFromMessages: function(messages) {\n    var connect = this.filter([].concat(messages), function(message) {\n      return message.channel === '/meta/connect';\n    });\n    return connect[0] && connect[0].clientId;\n  },\n\n  copyObject: function(object) {\n    var clone, i, key;\n    if (object instanceof Array) {\n      clone = [];\n      i = object.length;\n      while (i--) clone[i] = Faye.copyObject(object[i]);\n      return clone;\n    } else if (typeof object === 'object') {\n      clone = (object === null) ? null : {};\n      for (key in object) clone[key] = Faye.copyObject(object[key]);\n      return clone;\n    } else {\n      return object;\n    }\n  },\n\n  commonElement: function(lista, listb) {\n    for (var i = 0, n = lista.length; i < n; i++) {\n      if (this.indexOf(listb, lista[i]) !== -1)\n        return lista[i];\n    }\n    return null;\n  },\n\n  indexOf: function(list, needle) {\n    if (list.indexOf) return list.indexOf(needle);\n\n    for (var i = 0, n = list.length; i < n; i++) {\n      if (list[i] === needle) return i;\n    }\n    return -1;\n  },\n\n  map: function(object, callback, context) {\n    if (object.map) return object.map(callback, context);\n    var result = [];\n\n    if (object instanceof Array) {\n      for (var i = 0, n = object.length; i < n; i++) {\n        result.push(callback.call(context || null, object[i], i));\n      }\n    } else {\n      for (var key in object) {\n        if (!object.hasOwnProperty(key)) continue;\n        result.push(callback.call(context || null, key, object[key]));\n      }\n    }\n    return result;\n  },\n\n  filter: function(array, callback, context) {\n    if (array.filter) return array.filter(callback, context);\n    var result = [];\n    for (var i = 0, n = array.length; i < n; i++) {\n      if (callback.call(context || null, array[i], i))\n        result.push(array[i]);\n    }\n    return result;\n  },\n\n  asyncEach: function(list, iterator, callback, context) {\n    var n       = list.length,\n        i       = -1,\n        calls   = 0,\n        looping = false;\n\n    var iterate = function() {\n      calls -= 1;\n      i += 1;\n      if (i === n) return callback && callback.call(context);\n      iterator(list[i], resume);\n    };\n\n    var loop = function() {\n      if (looping) return;\n      looping = true;\n      while (calls > 0) iterate();\n      looping = false;\n    };\n\n    var resume = function() {\n      calls += 1;\n      loop();\n    };\n    resume();\n  },\n\n  // http://assanka.net/content/tech/2009/09/02/json2-js-vs-prototype/\n  toJSON: function(object) {\n    if (!this.stringify) return JSON.stringify(object);\n\n    return this.stringify(object, function(key, value) {\n      return (this[key] instanceof Array) ? this[key] : value;\n    });\n  }\n};\n\nif (typeof module !== 'undefined')\n  module.exports = Faye;\nelse if (typeof window !== 'undefined')\n  window.Faye = Faye;\n\nFaye.Class = function(parent, methods) {\n  if (typeof parent !== 'function') {\n    methods = parent;\n    parent  = Object;\n  }\n\n  var klass = function() {\n    if (!this.initialize) return this;\n    return this.initialize.apply(this, arguments) || this;\n  };\n\n  var bridge = function() {};\n  bridge.prototype = parent.prototype;\n\n  klass.prototype = new bridge();\n  Faye.extend(klass.prototype, methods);\n\n  return klass;\n};\n\n(function() {\nvar EventEmitter = Faye.EventEmitter = function() {};\n\n/*\nCopyright Joyent, Inc. and other Node contributors. All rights reserved.\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\nof the Software, and to permit persons to whom the Software is furnished to do\nso, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\n\nvar isArray = typeof Array.isArray === 'function'\n    ? Array.isArray\n    : function (xs) {\n        return Object.prototype.toString.call(xs) === '[object Array]'\n    }\n;\nfunction indexOf (xs, x) {\n    if (xs.indexOf) return xs.indexOf(x);\n    for (var i = 0; i < xs.length; i++) {\n        if (x === xs[i]) return i;\n    }\n    return -1;\n}\n\n\nEventEmitter.prototype.emit = function(type) {\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events || !this._events.error ||\n        (isArray(this._events.error) && !this._events.error.length))\n    {\n      if (arguments[1] instanceof Error) {\n        throw arguments[1]; // Unhandled 'error' event\n      } else {\n        throw new Error(\"Uncaught, unspecified 'error' event.\");\n      }\n      return false;\n    }\n  }\n\n  if (!this._events) return false;\n  var handler = this._events[type];\n  if (!handler) return false;\n\n  if (typeof handler == 'function') {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        var args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n    return true;\n\n  } else if (isArray(handler)) {\n    var args = Array.prototype.slice.call(arguments, 1);\n\n    var listeners = handler.slice();\n    for (var i = 0, l = listeners.length; i < l; i++) {\n      listeners[i].apply(this, args);\n    }\n    return true;\n\n  } else {\n    return false;\n  }\n};\n\n// EventEmitter is defined in src/node_events.cc\n// EventEmitter.prototype.emit() is also defined there.\nEventEmitter.prototype.addListener = function(type, listener) {\n  if ('function' !== typeof listener) {\n    throw new Error('addListener only takes instances of Function');\n  }\n\n  if (!this._events) this._events = {};\n\n  // To avoid recursion in the case that type == \"newListeners\"! Before\n  // adding it to the listeners, first emit \"newListeners\".\n  this.emit('newListener', type, listener);\n\n  if (!this._events[type]) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  } else if (isArray(this._events[type])) {\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  } else {\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  var self = this;\n  self.on(type, function g() {\n    self.removeListener(type, g);\n    listener.apply(this, arguments);\n  });\n\n  return this;\n};\n\nEventEmitter.prototype.removeListener = function(type, listener) {\n  if ('function' !== typeof listener) {\n    throw new Error('removeListener only takes instances of Function');\n  }\n\n  // does not use listeners(), so no side effect of creating _events[type]\n  if (!this._events || !this._events[type]) return this;\n\n  var list = this._events[type];\n\n  if (isArray(list)) {\n    var i = indexOf(list, listener);\n    if (i < 0) return this;\n    list.splice(i, 1);\n    if (list.length == 0)\n      delete this._events[type];\n  } else if (this._events[type] === listener) {\n    delete this._events[type];\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  if (arguments.length === 0) {\n    this._events = {};\n    return this;\n  }\n\n  // does not use listeners(), so no side effect of creating _events[type]\n  if (type && this._events && this._events[type]) this._events[type] = null;\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  if (!this._events) this._events = {};\n  if (!this._events[type]) this._events[type] = [];\n  if (!isArray(this._events[type])) {\n    this._events[type] = [this._events[type]];\n  }\n  return this._events[type];\n};\n\n})();\n\nFaye.Namespace = Faye.Class({\n  initialize: function() {\n    this._used = {};\n  },\n\n  exists: function(id) {\n    return this._used.hasOwnProperty(id);\n  },\n\n  generate: function() {\n    var name = Faye.random();\n    while (this._used.hasOwnProperty(name))\n      name = Faye.random();\n    return this._used[name] = name;\n  },\n\n  release: function(id) {\n    delete this._used[id];\n  }\n});\n\n(function() {\n'use strict';\n\nvar timeout = setTimeout, defer;\n\nif (typeof setImmediate === 'function')\n  defer = function(fn) { setImmediate(fn) };\nelse if (typeof process === 'object' && process.nextTick)\n  defer = function(fn) { process.nextTick(fn) };\nelse\n  defer = function(fn) { timeout(fn, 0) };\n\nvar PENDING   = 0,\n    FULFILLED = 1,\n    REJECTED  = 2;\n\nvar RETURN = function(x) { return x },\n    THROW  = function(x) { throw  x };\n\nvar Promise = function(task) {\n  this._state       = PENDING;\n  this._onFulfilled = [];\n  this._onRejected  = [];\n\n  if (typeof task !== 'function') return;\n  var self = this;\n\n  task(function(value)  { fulfill(self, value) },\n       function(reason) { reject(self, reason) });\n};\n\nPromise.prototype.then = function(onFulfilled, onRejected) {\n  var next = new Promise();\n  registerOnFulfilled(this, onFulfilled, next);\n  registerOnRejected(this, onRejected, next);\n  return next;\n};\n\nvar registerOnFulfilled = function(promise, onFulfilled, next) {\n  if (typeof onFulfilled !== 'function') onFulfilled = RETURN;\n  var handler = function(value) { invoke(onFulfilled, value, next) };\n\n  if (promise._state === PENDING) {\n    promise._onFulfilled.push(handler);\n  } else if (promise._state === FULFILLED) {\n    handler(promise._value);\n  }\n};\n\nvar registerOnRejected = function(promise, onRejected, next) {\n  if (typeof onRejected !== 'function') onRejected = THROW;\n  var handler = function(reason) { invoke(onRejected, reason, next) };\n\n  if (promise._state === PENDING) {\n    promise._onRejected.push(handler);\n  } else if (promise._state === REJECTED) {\n    handler(promise._reason);\n  }\n};\n\nvar invoke = function(fn, value, next) {\n  defer(function() { _invoke(fn, value, next) });\n};\n\nvar _invoke = function(fn, value, next) {\n  var outcome;\n\n  try {\n    outcome = fn(value);\n  } catch (error) {\n    return reject(next, error);\n  }\n\n  if (outcome === next) {\n    reject(next, new TypeError('Recursive promise chain detected'));\n  } else {\n    fulfill(next, outcome);\n  }\n};\n\nvar fulfill = Promise.fulfill = Promise.resolve = function(promise, value) {\n  var called = false, type, then;\n\n  try {\n    type = typeof value;\n    then = value !== null && (type === 'function' || type === 'object') && value.then;\n\n    if (typeof then !== 'function') return _fulfill(promise, value);\n\n    then.call(value, function(v) {\n      if (!(called ^ (called = true))) return;\n      fulfill(promise, v);\n    }, function(r) {\n      if (!(called ^ (called = true))) return;\n      reject(promise, r);\n    });\n  } catch (error) {\n    if (!(called ^ (called = true))) return;\n    reject(promise, error);\n  }\n};\n\nvar _fulfill = function(promise, value) {\n  if (promise._state !== PENDING) return;\n\n  promise._state      = FULFILLED;\n  promise._value      = value;\n  promise._onRejected = [];\n\n  var onFulfilled = promise._onFulfilled, fn;\n  while (fn = onFulfilled.shift()) fn(value);\n};\n\nvar reject = Promise.reject = function(promise, reason) {\n  if (promise._state !== PENDING) return;\n\n  promise._state       = REJECTED;\n  promise._reason      = reason;\n  promise._onFulfilled = [];\n\n  var onRejected = promise._onRejected, fn;\n  while (fn = onRejected.shift()) fn(reason);\n};\n\nPromise.all = function(promises) {\n  return new Promise(function(fulfill, reject) {\n    var list = [],\n         n   = promises.length,\n         i;\n\n    if (n === 0) return fulfill(list);\n\n    for (i = 0; i < n; i++) (function(promise, i) {\n      Promise.fulfilled(promise).then(function(value) {\n        list[i] = value;\n        if (--n === 0) fulfill(list);\n      }, reject);\n    })(promises[i], i);\n  });\n};\n\nPromise.defer = defer;\n\nPromise.deferred = Promise.pending = function() {\n  var tuple = {};\n\n  tuple.promise = new Promise(function(fulfill, reject) {\n    tuple.fulfill = tuple.resolve = fulfill;\n    tuple.reject  = reject;\n  });\n  return tuple;\n};\n\nPromise.fulfilled = Promise.resolved = function(value) {\n  return new Promise(function(fulfill, reject) { fulfill(value) });\n};\n\nPromise.rejected = function(reason) {\n  return new Promise(function(fulfill, reject) { reject(reason) });\n};\n\nif (typeof Faye === 'undefined')\n  module.exports = Promise;\nelse\n  Faye.Promise = Promise;\n\n})();\n\nFaye.Set = Faye.Class({\n  initialize: function() {\n    this._index = {};\n  },\n\n  add: function(item) {\n    var key = (item.id !== undefined) ? item.id : item;\n    if (this._index.hasOwnProperty(key)) return false;\n    this._index[key] = item;\n    return true;\n  },\n\n  forEach: function(block, context) {\n    for (var key in this._index) {\n      if (this._index.hasOwnProperty(key))\n        block.call(context, this._index[key]);\n    }\n  },\n\n  isEmpty: function() {\n    for (var key in this._index) {\n      if (this._index.hasOwnProperty(key)) return false;\n    }\n    return true;\n  },\n\n  member: function(item) {\n    for (var key in this._index) {\n      if (this._index[key] === item) return true;\n    }\n    return false;\n  },\n\n  remove: function(item) {\n    var key = (item.id !== undefined) ? item.id : item;\n    var removed = this._index[key];\n    delete this._index[key];\n    return removed;\n  },\n\n  toArray: function() {\n    var array = [];\n    this.forEach(function(item) { array.push(item) });\n    return array;\n  }\n});\n\nFaye.URI = {\n  isURI: function(uri) {\n    return uri && uri.protocol && uri.host && uri.path;\n  },\n\n  isSameOrigin: function(uri) {\n    var location = Faye.ENV.location;\n    return uri.protocol === location.protocol &&\n           uri.hostname === location.hostname &&\n           uri.port     === location.port;\n  },\n\n  parse: function(url) {\n    if (typeof url !== 'string') return url;\n    var uri = {}, parts, query, pairs, i, n, data;\n\n    var consume = function(name, pattern) {\n      url = url.replace(pattern, function(match) {\n        uri[name] = match;\n        return '';\n      });\n      uri[name] = uri[name] || '';\n    };\n\n    consume('protocol', /^[a-z]+\\:/i);\n    consume('host',     /^\\/\\/[^\\/\\?#]+/);\n\n    if (!/^\\//.test(url) && !uri.host)\n      url = Faye.ENV.location.pathname.replace(/[^\\/]*$/, '') + url;\n\n    consume('pathname', /^[^\\?#]*/);\n    consume('search',   /^\\?[^#]*/);\n    consume('hash',     /^#.*/);\n\n    uri.protocol = uri.protocol || Faye.ENV.location.protocol;\n\n    if (uri.host) {\n      uri.host     = uri.host.substr(2);\n      parts        = uri.host.split(':');\n      uri.hostname = parts[0];\n      uri.port     = parts[1] || '';\n    } else {\n      uri.host     = Faye.ENV.location.host;\n      uri.hostname = Faye.ENV.location.hostname;\n      uri.port     = Faye.ENV.location.port;\n    }\n\n    uri.pathname = uri.pathname || '/';\n    uri.path = uri.pathname + uri.search;\n\n    query = uri.search.replace(/^\\?/, '');\n    pairs = query ? query.split('&') : [];\n    data  = {};\n\n    for (i = 0, n = pairs.length; i < n; i++) {\n      parts = pairs[i].split('=');\n      data[decodeURIComponent(parts[0] || '')] = decodeURIComponent(parts[1] || '');\n    }\n\n    uri.query = data;\n\n    uri.href = this.stringify(uri);\n    return uri;\n  },\n\n  stringify: function(uri) {\n    var string = uri.protocol + '//' + uri.hostname;\n    if (uri.port) string += ':' + uri.port;\n    string += uri.pathname + this.queryString(uri.query) + (uri.hash || '');\n    return string;\n  },\n\n  queryString: function(query) {\n    var pairs = [];\n    for (var key in query) {\n      if (!query.hasOwnProperty(key)) continue;\n      pairs.push(encodeURIComponent(key) + '=' + encodeURIComponent(query[key]));\n    }\n    if (pairs.length === 0) return '';\n    return '?' + pairs.join('&');\n  }\n};\n\nFaye.Error = Faye.Class({\n  initialize: function(code, params, message) {\n    this.code    = code;\n    this.params  = Array.prototype.slice.call(params);\n    this.message = message;\n  },\n\n  toString: function() {\n    return this.code + ':' +\n           this.params.join(',') + ':' +\n           this.message;\n  }\n});\n\nFaye.Error.parse = function(message) {\n  message = message || '';\n  if (!Faye.Grammar.ERROR.test(message)) return new this(null, [], message);\n\n  var parts   = message.split(':'),\n      code    = parseInt(parts[0]),\n      params  = parts[1].split(','),\n      message = parts[2];\n\n  return new this(code, params, message);\n};\n\n\n\n\nFaye.Error.versionMismatch = function() {\n  return new this(300, arguments, 'Version mismatch').toString();\n};\n\nFaye.Error.conntypeMismatch = function() {\n  return new this(301, arguments, 'Connection types not supported').toString();\n};\n\nFaye.Error.extMismatch = function() {\n  return new this(302, arguments, 'Extension mismatch').toString();\n};\n\nFaye.Error.badRequest = function() {\n  return new this(400, arguments, 'Bad request').toString();\n};\n\nFaye.Error.clientUnknown = function() {\n  return new this(401, arguments, 'Unknown client').toString();\n};\n\nFaye.Error.parameterMissing = function() {\n  return new this(402, arguments, 'Missing required parameter').toString();\n};\n\nFaye.Error.channelForbidden = function() {\n  return new this(403, arguments, 'Forbidden channel').toString();\n};\n\nFaye.Error.channelUnknown = function() {\n  return new this(404, arguments, 'Unknown channel').toString();\n};\n\nFaye.Error.channelInvalid = function() {\n  return new this(405, arguments, 'Invalid channel').toString();\n};\n\nFaye.Error.extUnknown = function() {\n  return new this(406, arguments, 'Unknown extension').toString();\n};\n\nFaye.Error.publishFailed = function() {\n  return new this(407, arguments, 'Failed to publish').toString();\n};\n\nFaye.Error.serverError = function() {\n  return new this(500, arguments, 'Internal server error').toString();\n};\n\n\nFaye.Deferrable = {\n  then: function(callback, errback) {\n    var self = this;\n    if (!this._promise)\n      this._promise = new Faye.Promise(function(fulfill, reject) {\n        self._fulfill = fulfill;\n        self._reject  = reject;\n      });\n\n    if (arguments.length === 0)\n      return this._promise;\n    else\n      return this._promise.then(callback, errback);\n  },\n\n  callback: function(callback, context) {\n    return this.then(function(value) { callback.call(context, value) });\n  },\n\n  errback: function(callback, context) {\n    return this.then(null, function(reason) { callback.call(context, reason) });\n  },\n\n  timeout: function(seconds, message) {\n    this.then();\n    var self = this;\n    this._timer = Faye.ENV.setTimeout(function() {\n      self._reject(message);\n    }, seconds * 1000);\n  },\n\n  setDeferredStatus: function(status, value) {\n    if (this._timer) Faye.ENV.clearTimeout(this._timer);\n\n    this.then();\n\n    if (status === 'succeeded')\n      this._fulfill(value);\n    else if (status === 'failed')\n      this._reject(value);\n    else\n      delete this._promise;\n  }\n};\n\nFaye.Publisher = {\n  countListeners: function(eventType) {\n    return this.listeners(eventType).length;\n  },\n\n  bind: function(eventType, listener, context) {\n    var slice   = Array.prototype.slice,\n        handler = function() { listener.apply(context, slice.call(arguments)) };\n\n    this._listeners = this._listeners || [];\n    this._listeners.push([eventType, listener, context, handler]);\n    return this.on(eventType, handler);\n  },\n\n  unbind: function(eventType, listener, context) {\n    this._listeners = this._listeners || [];\n    var n = this._listeners.length, tuple;\n\n    while (n--) {\n      tuple = this._listeners[n];\n      if (tuple[0] !== eventType) continue;\n      if (listener && (tuple[1] !== listener || tuple[2] !== context)) continue;\n      this._listeners.splice(n, 1);\n      this.removeListener(eventType, tuple[3]);\n    }\n  }\n};\n\nFaye.extend(Faye.Publisher, Faye.EventEmitter.prototype);\nFaye.Publisher.trigger = Faye.Publisher.emit;\n\nFaye.Timeouts = {\n  addTimeout: function(name, delay, callback, context) {\n    this._timeouts = this._timeouts || {};\n    if (this._timeouts.hasOwnProperty(name)) return;\n    var self = this;\n    this._timeouts[name] = Faye.ENV.setTimeout(function() {\n      delete self._timeouts[name];\n      callback.call(context);\n    }, 1000 * delay);\n  },\n\n  removeTimeout: function(name) {\n    this._timeouts = this._timeouts || {};\n    var timeout = this._timeouts[name];\n    if (!timeout) return;\n    Faye.ENV.clearTimeout(timeout);\n    delete this._timeouts[name];\n  },\n\n  removeAllTimeouts: function() {\n    this._timeouts = this._timeouts || {};\n    for (var name in this._timeouts) this.removeTimeout(name);\n  }\n};\n\nFaye.Logging = {\n  LOG_LEVELS: {\n    fatal:  4,\n    error:  3,\n    warn:   2,\n    info:   1,\n    debug:  0\n  },\n\n  writeLog: function(messageArgs, level) {\n    if (!Faye.logger) return;\n\n    var args   = Array.prototype.slice.apply(messageArgs),\n        banner = '[Faye',\n        klass  = this.className,\n\n        message = args.shift().replace(/\\?/g, function() {\n          try {\n            return Faye.toJSON(args.shift());\n          } catch (e) {\n            return '[Object]';\n          }\n        });\n\n    for (var key in Faye) {\n      if (klass) continue;\n      if (typeof Faye[key] !== 'function') continue;\n      if (this instanceof Faye[key]) klass = key;\n    }\n    if (klass) banner += '.' + klass;\n    banner += '] ';\n\n    if (typeof Faye.logger[level] === 'function')\n      Faye.logger[level](banner + message);\n    else if (typeof Faye.logger === 'function')\n      Faye.logger(banner + message);\n  }\n};\n\n(function() {\n  for (var key in Faye.Logging.LOG_LEVELS)\n    (function(level) {\n      Faye.Logging[level] = function() {\n        this.writeLog(arguments, level);\n      };\n    })(key);\n})();\n\nFaye.Grammar = {\n  CHANNEL_NAME:     /^\\/(((([a-z]|[A-Z])|[0-9])|(\\-|\\_|\\!|\\~|\\(|\\)|\\$|\\@)))+(\\/(((([a-z]|[A-Z])|[0-9])|(\\-|\\_|\\!|\\~|\\(|\\)|\\$|\\@)))+)*$/,\n  CHANNEL_PATTERN:  /^(\\/(((([a-z]|[A-Z])|[0-9])|(\\-|\\_|\\!|\\~|\\(|\\)|\\$|\\@)))+)*\\/\\*{1,2}$/,\n  ERROR:            /^([0-9][0-9][0-9]:(((([a-z]|[A-Z])|[0-9])|(\\-|\\_|\\!|\\~|\\(|\\)|\\$|\\@)| |\\/|\\*|\\.))*(,(((([a-z]|[A-Z])|[0-9])|(\\-|\\_|\\!|\\~|\\(|\\)|\\$|\\@)| |\\/|\\*|\\.))*)*:(((([a-z]|[A-Z])|[0-9])|(\\-|\\_|\\!|\\~|\\(|\\)|\\$|\\@)| |\\/|\\*|\\.))*|[0-9][0-9][0-9]::(((([a-z]|[A-Z])|[0-9])|(\\-|\\_|\\!|\\~|\\(|\\)|\\$|\\@)| |\\/|\\*|\\.))*)$/,\n  VERSION:          /^([0-9])+(\\.(([a-z]|[A-Z])|[0-9])(((([a-z]|[A-Z])|[0-9])|\\-|\\_))*)*$/\n};\n\nFaye.Extensible = {\n  addExtension: function(extension) {\n    this._extensions = this._extensions || [];\n    this._extensions.push(extension);\n    if (extension.added) extension.added(this);\n  },\n\n  removeExtension: function(extension) {\n    if (!this._extensions) return;\n    var i = this._extensions.length;\n    while (i--) {\n      if (this._extensions[i] !== extension) continue;\n      this._extensions.splice(i,1);\n      if (extension.removed) extension.removed(this);\n    }\n  },\n\n  pipeThroughExtensions: function(stage, message, request, callback, context) {\n    this.debug('Passing through ? extensions: ?', stage, message);\n\n    if (!this._extensions) return callback.call(context, message);\n    var extensions = this._extensions.slice();\n\n    var pipe = function(message) {\n      if (!message) return callback.call(context, message);\n\n      var extension = extensions.shift();\n      if (!extension) return callback.call(context, message);\n\n      var fn = extension[stage];\n      if (!fn) return pipe(message);\n\n      if (fn.length >= 3) extension[stage](message, request, pipe);\n      else                extension[stage](message, pipe);\n    };\n    pipe(message);\n  }\n};\n\nFaye.extend(Faye.Extensible, Faye.Logging);\n\nFaye.Channel = Faye.Class({\n  initialize: function(name) {\n    this.id = this.name = name;\n  },\n\n  push: function(message) {\n    this.trigger('message', message);\n  },\n\n  isUnused: function() {\n    return this.countListeners('message') === 0;\n  }\n});\n\nFaye.extend(Faye.Channel.prototype, Faye.Publisher);\n\nFaye.extend(Faye.Channel, {\n  HANDSHAKE:    '/meta/handshake',\n  CONNECT:      '/meta/connect',\n  SUBSCRIBE:    '/meta/subscribe',\n  UNSUBSCRIBE:  '/meta/unsubscribe',\n  DISCONNECT:   '/meta/disconnect',\n\n  META:         'meta',\n  SERVICE:      'service',\n\n  expand: function(name) {\n    var segments = this.parse(name),\n        channels = ['/**', name];\n\n    var copy = segments.slice();\n    copy[copy.length - 1] = '*';\n    channels.push(this.unparse(copy));\n\n    for (var i = 1, n = segments.length; i < n; i++) {\n      copy = segments.slice(0, i);\n      copy.push('**');\n      channels.push(this.unparse(copy));\n    }\n\n    return channels;\n  },\n\n  isValid: function(name) {\n    return Faye.Grammar.CHANNEL_NAME.test(name) ||\n           Faye.Grammar.CHANNEL_PATTERN.test(name);\n  },\n\n  parse: function(name) {\n    if (!this.isValid(name)) return null;\n    return name.split('/').slice(1);\n  },\n\n  unparse: function(segments) {\n    return '/' + segments.join('/');\n  },\n\n  isMeta: function(name) {\n    var segments = this.parse(name);\n    return segments ? (segments[0] === this.META) : null;\n  },\n\n  isService: function(name) {\n    var segments = this.parse(name);\n    return segments ? (segments[0] === this.SERVICE) : null;\n  },\n\n  isSubscribable: function(name) {\n    if (!this.isValid(name)) return null;\n    return !this.isMeta(name) && !this.isService(name);\n  },\n\n  Set: Faye.Class({\n    initialize: function() {\n      this._channels = {};\n    },\n\n    getKeys: function() {\n      var keys = [];\n      for (var key in this._channels) keys.push(key);\n      return keys;\n    },\n\n    remove: function(name) {\n      delete this._channels[name];\n    },\n\n    hasSubscription: function(name) {\n      return this._channels.hasOwnProperty(name);\n    },\n\n    subscribe: function(names, callback, context) {\n      var name;\n      for (var i = 0, n = names.length; i < n; i++) {\n        name = names[i];\n        var channel = this._channels[name] = this._channels[name] || new Faye.Channel(name);\n        if (callback) channel.bind('message', callback, context);\n      }\n    },\n\n    unsubscribe: function(name, callback, context) {\n      var channel = this._channels[name];\n      if (!channel) return false;\n      channel.unbind('message', callback, context);\n\n      if (channel.isUnused()) {\n        this.remove(name);\n        return true;\n      } else {\n        return false;\n      }\n    },\n\n    distributeMessage: function(message) {\n      var channels = Faye.Channel.expand(message.channel);\n\n      for (var i = 0, n = channels.length; i < n; i++) {\n        var channel = this._channels[channels[i]];\n        if (channel) channel.trigger('message', message.data);\n      }\n    }\n  })\n});\n\nFaye.Publication = Faye.Class(Faye.Deferrable);\n\nFaye.Subscription = Faye.Class({\n  initialize: function(client, channels, callback, context) {\n    this._client    = client;\n    this._channels  = channels;\n    this._callback  = callback;\n    this._context     = context;\n    this._cancelled = false;\n  },\n\n  cancel: function() {\n    if (this._cancelled) return;\n    this._client.unsubscribe(this._channels, this._callback, this._context);\n    this._cancelled = true;\n  },\n\n  unsubscribe: function() {\n    this.cancel();\n  }\n});\n\nFaye.extend(Faye.Subscription.prototype, Faye.Deferrable);\n\nFaye.Client = Faye.Class({\n  UNCONNECTED:        1,\n  CONNECTING:         2,\n  CONNECTED:          3,\n  DISCONNECTED:       4,\n\n  HANDSHAKE:          'handshake',\n  RETRY:              'retry',\n  NONE:               'none',\n\n  CONNECTION_TIMEOUT: 60,\n\n  DEFAULT_ENDPOINT:   '/bayeux',\n  INTERVAL:           0,\n\n  initialize: function(endpoint, options) {\n    this.info('New client created for ?', endpoint);\n    options = options || {};\n\n    Faye.validateOptions(options, ['interval', 'timeout', 'endpoints', 'proxy', 'retry', 'scheduler', 'websocketExtensions', 'tls', 'ca']);\n\n    this._endpoint   = endpoint || this.DEFAULT_ENDPOINT;\n    this._channels   = new Faye.Channel.Set();\n    this._dispatcher = new Faye.Dispatcher(this, this._endpoint, options);\n\n    this._messageId = 0;\n    this._state     = this.UNCONNECTED;\n\n    this._responseCallbacks = {};\n\n    this._advice = {\n      reconnect: this.RETRY,\n      interval:  1000 * (options.interval || this.INTERVAL),\n      timeout:   1000 * (options.timeout  || this.CONNECTION_TIMEOUT)\n    };\n    this._dispatcher.timeout = this._advice.timeout / 1000;\n\n    this._dispatcher.bind('message', this._receiveMessage, this);\n\n    if (Faye.Event && Faye.ENV.onbeforeunload !== undefined)\n      Faye.Event.on(Faye.ENV, 'beforeunload', function() {\n        if (Faye.indexOf(this._dispatcher._disabled, 'autodisconnect') < 0)\n          this.disconnect();\n      }, this);\n  },\n\n  addWebsocketExtension: function(extension) {\n    return this._dispatcher.addWebsocketExtension(extension);\n  },\n\n  disable: function(feature) {\n    return this._dispatcher.disable(feature);\n  },\n\n  setHeader: function(name, value) {\n    return this._dispatcher.setHeader(name, value);\n  },\n\n  // Request\n  // MUST include:  * channel\n  //                * version\n  //                * supportedConnectionTypes\n  // MAY include:   * minimumVersion\n  //                * ext\n  //                * id\n  //\n  // Success Response                             Failed Response\n  // MUST include:  * channel                     MUST include:  * channel\n  //                * version                                    * successful\n  //                * supportedConnectionTypes                   * error\n  //                * clientId                    MAY include:   * supportedConnectionTypes\n  //                * successful                                 * advice\n  // MAY include:   * minimumVersion                             * version\n  //                * advice                                     * minimumVersion\n  //                * ext                                        * ext\n  //                * id                                         * id\n  //                * authSuccessful\n  handshake: function(callback, context) {\n    if (this._advice.reconnect === this.NONE) return;\n    if (this._state !== this.UNCONNECTED) return;\n\n    this._state = this.CONNECTING;\n    var self = this;\n\n    this.info('Initiating handshake with ?', Faye.URI.stringify(this._endpoint));\n    this._dispatcher.selectTransport(Faye.MANDATORY_CONNECTION_TYPES);\n\n    this._sendMessage({\n      channel:                  Faye.Channel.HANDSHAKE,\n      version:                  Faye.BAYEUX_VERSION,\n      supportedConnectionTypes: this._dispatcher.getConnectionTypes()\n\n    }, {}, function(response) {\n\n      if (response.successful) {\n        this._state = this.CONNECTED;\n        this._dispatcher.clientId  = response.clientId;\n\n        this._dispatcher.selectTransport(response.supportedConnectionTypes);\n\n        this.info('Handshake successful: ?', this._dispatcher.clientId);\n\n        this.subscribe(this._channels.getKeys(), true);\n        if (callback) Faye.Promise.defer(function() { callback.call(context) });\n\n      } else {\n        this.info('Handshake unsuccessful');\n        Faye.ENV.setTimeout(function() { self.handshake(callback, context) }, this._dispatcher.retry * 1000);\n        this._state = this.UNCONNECTED;\n      }\n    }, this);\n  },\n\n  // Request                              Response\n  // MUST include:  * channel             MUST include:  * channel\n  //                * clientId                           * successful\n  //                * connectionType                     * clientId\n  // MAY include:   * ext                 MAY include:   * error\n  //                * id                                 * advice\n  //                                                     * ext\n  //                                                     * id\n  //                                                     * timestamp\n  connect: function(callback, context) {\n    if (this._advice.reconnect === this.NONE) return;\n    if (this._state === this.DISCONNECTED) return;\n\n    if (this._state === this.UNCONNECTED)\n      return this.handshake(function() { this.connect(callback, context) }, this);\n\n    this.callback(callback, context);\n    if (this._state !== this.CONNECTED) return;\n\n    this.info('Calling deferred actions for ?', this._dispatcher.clientId);\n    this.setDeferredStatus('succeeded');\n    this.setDeferredStatus('unknown');\n\n    if (this._connectRequest) return;\n    this._connectRequest = true;\n\n    this.info('Initiating connection for ?', this._dispatcher.clientId);\n\n    this._sendMessage({\n      channel:        Faye.Channel.CONNECT,\n      clientId:       this._dispatcher.clientId,\n      connectionType: this._dispatcher.connectionType\n\n    }, {}, this._cycleConnection, this);\n  },\n\n  // Request                              Response\n  // MUST include:  * channel             MUST include:  * channel\n  //                * clientId                           * successful\n  // MAY include:   * ext                                * clientId\n  //                * id                  MAY include:   * error\n  //                                                     * ext\n  //                                                     * id\n  disconnect: function() {\n    if (this._state !== this.CONNECTED) return;\n    this._state = this.DISCONNECTED;\n\n    this.info('Disconnecting ?', this._dispatcher.clientId);\n    var promise = new Faye.Publication();\n\n    this._sendMessage({\n      channel:  Faye.Channel.DISCONNECT,\n      clientId: this._dispatcher.clientId\n\n    }, {}, function(response) {\n      if (response.successful) {\n        this._dispatcher.close();\n        promise.setDeferredStatus('succeeded');\n      } else {\n        promise.setDeferredStatus('failed', Faye.Error.parse(response.error));\n      }\n    }, this);\n\n    this.info('Clearing channel listeners for ?', this._dispatcher.clientId);\n    this._channels = new Faye.Channel.Set();\n\n    return promise;\n  },\n\n  // Request                              Response\n  // MUST include:  * channel             MUST include:  * channel\n  //                * clientId                           * successful\n  //                * subscription                       * clientId\n  // MAY include:   * ext                                * subscription\n  //                * id                  MAY include:   * error\n  //                                                     * advice\n  //                                                     * ext\n  //                                                     * id\n  //                                                     * timestamp\n  subscribe: function(channel, callback, context) {\n    if (channel instanceof Array)\n      return Faye.map(channel, function(c) {\n        return this.subscribe(c, callback, context);\n      }, this);\n\n    var subscription = new Faye.Subscription(this, channel, callback, context),\n        force        = (callback === true),\n        hasSubscribe = this._channels.hasSubscription(channel);\n\n    if (hasSubscribe && !force) {\n      this._channels.subscribe([channel], callback, context);\n      subscription.setDeferredStatus('succeeded');\n      return subscription;\n    }\n\n    this.connect(function() {\n      this.info('Client ? attempting to subscribe to ?', this._dispatcher.clientId, channel);\n      if (!force) this._channels.subscribe([channel], callback, context);\n\n      this._sendMessage({\n        channel:      Faye.Channel.SUBSCRIBE,\n        clientId:     this._dispatcher.clientId,\n        subscription: channel\n\n      }, {}, function(response) {\n        if (!response.successful) {\n          subscription.setDeferredStatus('failed', Faye.Error.parse(response.error));\n          return this._channels.unsubscribe(channel, callback, context);\n        }\n\n        var channels = [].concat(response.subscription);\n        this.info('Subscription acknowledged for ? to ?', this._dispatcher.clientId, channels);\n        subscription.setDeferredStatus('succeeded');\n      }, this);\n    }, this);\n\n    return subscription;\n  },\n\n  // Request                              Response\n  // MUST include:  * channel             MUST include:  * channel\n  //                * clientId                           * successful\n  //                * subscription                       * clientId\n  // MAY include:   * ext                                * subscription\n  //                * id                  MAY include:   * error\n  //                                                     * advice\n  //                                                     * ext\n  //                                                     * id\n  //                                                     * timestamp\n  unsubscribe: function(channel, callback, context) {\n    if (channel instanceof Array)\n      return Faye.map(channel, function(c) {\n        return this.unsubscribe(c, callback, context);\n      }, this);\n\n    var dead = this._channels.unsubscribe(channel, callback, context);\n    if (!dead) return;\n\n    this.connect(function() {\n      this.info('Client ? attempting to unsubscribe from ?', this._dispatcher.clientId, channel);\n\n      this._sendMessage({\n        channel:      Faye.Channel.UNSUBSCRIBE,\n        clientId:     this._dispatcher.clientId,\n        subscription: channel\n\n      }, {}, function(response) {\n        if (!response.successful) return;\n\n        var channels = [].concat(response.subscription);\n        this.info('Unsubscription acknowledged for ? from ?', this._dispatcher.clientId, channels);\n      }, this);\n    }, this);\n  },\n\n  // Request                              Response\n  // MUST include:  * channel             MUST include:  * channel\n  //                * data                               * successful\n  // MAY include:   * clientId            MAY include:   * id\n  //                * id                                 * error\n  //                * ext                                * ext\n  publish: function(channel, data, options) {\n    Faye.validateOptions(options || {}, ['attempts', 'deadline']);\n    var publication = new Faye.Publication();\n\n    this.connect(function() {\n      this.info('Client ? queueing published message to ?: ?', this._dispatcher.clientId, channel, data);\n\n      this._sendMessage({\n        channel:  channel,\n        data:     data,\n        clientId: this._dispatcher.clientId\n\n      }, options, function(response) {\n        if (response.successful)\n          publication.setDeferredStatus('succeeded');\n        else\n          publication.setDeferredStatus('failed', Faye.Error.parse(response.error));\n      }, this);\n    }, this);\n\n    return publication;\n  },\n\n  _sendMessage: function(message, options, callback, context) {\n    message.id = this._generateMessageId();\n\n    var timeout = this._advice.timeout\n                ? 1.2 * this._advice.timeout / 1000\n                : 1.2 * this._dispatcher.retry;\n\n    this.pipeThroughExtensions('outgoing', message, null, function(message) {\n      if (!message) return;\n      if (callback) this._responseCallbacks[message.id] = [callback, context];\n      this._dispatcher.sendMessage(message, timeout, options || {});\n    }, this);\n  },\n\n  _generateMessageId: function() {\n    this._messageId += 1;\n    if (this._messageId >= Math.pow(2,32)) this._messageId = 0;\n    return this._messageId.toString(36);\n  },\n\n  _receiveMessage: function(message) {\n    var id = message.id, callback;\n\n    if (message.successful !== undefined) {\n      callback = this._responseCallbacks[id];\n      delete this._responseCallbacks[id];\n    }\n\n    this.pipeThroughExtensions('incoming', message, null, function(message) {\n      if (!message) return;\n      if (message.advice) this._handleAdvice(message.advice);\n      this._deliverMessage(message);\n      if (callback) callback[0].call(callback[1], message);\n    }, this);\n  },\n\n  _handleAdvice: function(advice) {\n    Faye.extend(this._advice, advice);\n    this._dispatcher.timeout = this._advice.timeout / 1000;\n\n    if (this._advice.reconnect === this.HANDSHAKE && this._state !== this.DISCONNECTED) {\n      this._state = this.UNCONNECTED;\n      this._dispatcher.clientId = null;\n      this._cycleConnection();\n    }\n  },\n\n  _deliverMessage: function(message) {\n    if (!message.channel || message.data === undefined) return;\n    this.info('Client ? calling listeners for ? with ?', this._dispatcher.clientId, message.channel, message.data);\n    this._channels.distributeMessage(message);\n  },\n\n  _cycleConnection: function() {\n    if (this._connectRequest) {\n      this._connectRequest = null;\n      this.info('Closed connection for ?', this._dispatcher.clientId);\n    }\n    var self = this;\n    Faye.ENV.setTimeout(function() { self.connect() }, this._advice.interval);\n  }\n});\n\nFaye.extend(Faye.Client.prototype, Faye.Deferrable);\nFaye.extend(Faye.Client.prototype, Faye.Publisher);\nFaye.extend(Faye.Client.prototype, Faye.Logging);\nFaye.extend(Faye.Client.prototype, Faye.Extensible);\n\nFaye.Dispatcher = Faye.Class({\n  MAX_REQUEST_SIZE: 2048,\n  DEFAULT_RETRY:    5,\n\n  UP:   1,\n  DOWN: 2,\n\n  initialize: function(client, endpoint, options) {\n    this._client     = client;\n    this.endpoint    = Faye.URI.parse(endpoint);\n    this._alternates = options.endpoints || {};\n\n    this.cookies      = Faye.Cookies && new Faye.Cookies.CookieJar();\n    this._disabled    = [];\n    this._envelopes   = {};\n    this.headers      = {};\n    this.retry        = options.retry || this.DEFAULT_RETRY;\n    this._scheduler   = options.scheduler || Faye.Scheduler;\n    this._state       = 0;\n    this.transports   = {};\n    this.wsExtensions = [];\n\n    this.proxy = options.proxy || {};\n    if (typeof this._proxy === 'string') this._proxy = {origin: this._proxy};\n\n    var exts = options.websocketExtensions;\n    if (exts) {\n      exts = [].concat(exts);\n      for (var i = 0, n = exts.length; i < n; i++)\n        this.addWebsocketExtension(exts[i]);\n    }\n\n    this.tls = options.tls || {};\n    this.tls.ca = this.tls.ca || options.ca;\n\n    for (var type in this._alternates)\n      this._alternates[type] = Faye.URI.parse(this._alternates[type]);\n\n    this.maxRequestSize = this.MAX_REQUEST_SIZE;\n  },\n\n  endpointFor: function(connectionType) {\n    return this._alternates[connectionType] || this.endpoint;\n  },\n\n  addWebsocketExtension: function(extension) {\n    this.wsExtensions.push(extension);\n  },\n\n  disable: function(feature) {\n    this._disabled.push(feature);\n  },\n\n  setHeader: function(name, value) {\n    this.headers[name] = value;\n  },\n\n  close: function() {\n    var transport = this._transport;\n    delete this._transport;\n    if (transport) transport.close();\n  },\n\n  getConnectionTypes: function() {\n    return Faye.Transport.getConnectionTypes();\n  },\n\n  selectTransport: function(transportTypes) {\n    Faye.Transport.get(this, transportTypes, this._disabled, function(transport) {\n      this.debug('Selected ? transport for ?', transport.connectionType, Faye.URI.stringify(transport.endpoint));\n\n      if (transport === this._transport) return;\n      if (this._transport) this._transport.close();\n\n      this._transport = transport;\n      this.connectionType = transport.connectionType;\n    }, this);\n  },\n\n  sendMessage: function(message, timeout, options) {\n    options = options || {};\n\n    var id       = message.id,\n        attempts = options.attempts,\n        deadline = options.deadline && new Date().getTime() + (options.deadline * 1000),\n        envelope = this._envelopes[id],\n        scheduler;\n\n    if (!envelope) {\n      scheduler = new this._scheduler(message, {timeout: timeout, interval: this.retry, attempts: attempts, deadline: deadline});\n      envelope  = this._envelopes[id] = {message: message, scheduler: scheduler};\n    }\n\n    this._sendEnvelope(envelope);\n  },\n\n  _sendEnvelope: function(envelope) {\n    if (!this._transport) return;\n    if (envelope.request || envelope.timer) return;\n\n    var message   = envelope.message,\n        scheduler = envelope.scheduler,\n        self      = this;\n\n    if (!scheduler.isDeliverable()) {\n      scheduler.abort();\n      delete this._envelopes[message.id];\n      return;\n    }\n\n    envelope.timer = Faye.ENV.setTimeout(function() {\n      self.handleError(message);\n    }, scheduler.getTimeout() * 1000);\n\n    scheduler.send();\n    envelope.request = this._transport.sendMessage(message);\n  },\n\n  handleResponse: function(reply) {\n    var envelope = this._envelopes[reply.id];\n\n    if (reply.successful !== undefined && envelope) {\n      envelope.scheduler.succeed();\n      delete this._envelopes[reply.id];\n      Faye.ENV.clearTimeout(envelope.timer);\n    }\n\n    this.trigger('message', reply);\n\n    if (this._state === this.UP) return;\n    this._state = this.UP;\n    this._client.trigger('transport:up');\n  },\n\n  handleError: function(message, immediate) {\n    var envelope = this._envelopes[message.id],\n        request  = envelope && envelope.request,\n        self     = this;\n\n    if (!request) return;\n\n    request.then(function(req) {\n      if (req && req.abort) req.abort();\n    });\n\n    var scheduler = envelope.scheduler;\n    scheduler.fail();\n\n    Faye.ENV.clearTimeout(envelope.timer);\n    envelope.request = envelope.timer = null;\n\n    if (immediate) {\n      this._sendEnvelope(envelope);\n    } else {\n      envelope.timer = Faye.ENV.setTimeout(function() {\n        envelope.timer = null;\n        self._sendEnvelope(envelope);\n      }, scheduler.getInterval() * 1000);\n    }\n\n    if (this._state === this.DOWN) return;\n    this._state = this.DOWN;\n    this._client.trigger('transport:down');\n  }\n});\n\nFaye.extend(Faye.Dispatcher.prototype, Faye.Publisher);\nFaye.extend(Faye.Dispatcher.prototype, Faye.Logging);\n\nFaye.Scheduler = function(message, options) {\n  this.message  = message;\n  this.options  = options;\n  this.attempts = 0;\n};\n\nFaye.extend(Faye.Scheduler.prototype, {\n  getTimeout: function() {\n    return this.options.timeout;\n  },\n\n  getInterval: function() {\n    return this.options.interval;\n  },\n\n  isDeliverable: function() {\n    var attempts = this.options.attempts,\n        made     = this.attempts,\n        deadline = this.options.deadline,\n        now      = new Date().getTime();\n\n    if (attempts !== undefined && made >= attempts)\n      return false;\n\n    if (deadline !== undefined && now > deadline)\n      return false;\n\n    return true;\n  },\n\n  send: function() {\n    this.attempts += 1;\n  },\n\n  succeed: function() {},\n\n  fail: function() {},\n\n  abort: function() {}\n});\n\nFaye.Transport = Faye.extend(Faye.Class({\n  DEFAULT_PORTS:    {'http:': 80, 'https:': 443, 'ws:': 80, 'wss:': 443},\n  SECURE_PROTOCOLS: ['https:', 'wss:'],\n  MAX_DELAY:        0,\n\n  batching:  true,\n\n  initialize: function(dispatcher, endpoint) {\n    this._dispatcher = dispatcher;\n    this.endpoint    = endpoint;\n    this._outbox     = [];\n    this._proxy      = Faye.extend({}, this._dispatcher.proxy);\n\n    if (!this._proxy.origin && Faye.NodeAdapter) {\n      this._proxy.origin = Faye.indexOf(this.SECURE_PROTOCOLS, this.endpoint.protocol) >= 0\n                         ? (process.env.HTTPS_PROXY || process.env.https_proxy)\n                         : (process.env.HTTP_PROXY  || process.env.http_proxy);\n    }\n  },\n\n  close: function() {},\n\n  encode: function(messages) {\n    return '';\n  },\n\n  sendMessage: function(message) {\n    this.debug('Client ? sending message to ?: ?',\n               this._dispatcher.clientId, Faye.URI.stringify(this.endpoint), message);\n\n    if (!this.batching) return Faye.Promise.fulfilled(this.request([message]));\n\n    this._outbox.push(message);\n    this._promise = this._promise || new Faye.Promise();\n    this._flushLargeBatch();\n\n    if (message.channel === Faye.Channel.HANDSHAKE) {\n      this.addTimeout('publish', 0.01, this._flush, this);\n      return this._promise;\n    }\n\n    if (message.channel === Faye.Channel.CONNECT)\n      this._connectMessage = message;\n\n    this.addTimeout('publish', this.MAX_DELAY, this._flush, this);\n    return this._promise;\n  },\n\n  _flush: function() {\n    this.removeTimeout('publish');\n\n    if (this._outbox.length > 1 && this._connectMessage)\n      this._connectMessage.advice = {timeout: 0};\n\n    Faye.Promise.fulfill(this._promise, this.request(this._outbox));\n    delete this._promise;\n\n    this._connectMessage = null;\n    this._outbox = [];\n  },\n\n  _flushLargeBatch: function() {\n    var string = this.encode(this._outbox);\n    if (string.length < this._dispatcher.maxRequestSize) return;\n    var last = this._outbox.pop();\n    this._flush();\n    if (last) this._outbox.push(last);\n  },\n\n  _receive: function(replies) {\n    if (!replies) return;\n    replies = [].concat(replies);\n\n    this.debug('Client ? received from ? via ?: ?',\n               this._dispatcher.clientId, Faye.URI.stringify(this.endpoint), this.connectionType, replies);\n\n    for (var i = 0, n = replies.length; i < n; i++)\n      this._dispatcher.handleResponse(replies[i]);\n  },\n\n  _handleError: function(messages, immediate) {\n    messages = [].concat(messages);\n\n    this.debug('Client ? failed to send to ? via ?: ?',\n               this._dispatcher.clientId, Faye.URI.stringify(this.endpoint), this.connectionType, messages);\n\n    for (var i = 0, n = messages.length; i < n; i++)\n      this._dispatcher.handleError(messages[i]);\n  },\n\n  _getCookies: function() {\n    var cookies = this._dispatcher.cookies,\n        url     = Faye.URI.stringify(this.endpoint);\n\n    if (!cookies) return '';\n\n    return Faye.map(cookies.getCookiesSync(url), function(cookie) {\n      return cookie.cookieString();\n    }).join('; ');\n  },\n\n  _storeCookies: function(setCookie) {\n    var cookies = this._dispatcher.cookies,\n        url     = Faye.URI.stringify(this.endpoint),\n        cookie;\n\n    if (!setCookie || !cookies) return;\n    setCookie = [].concat(setCookie);\n\n    for (var i = 0, n = setCookie.length; i < n; i++) {\n      cookie = Faye.Cookies.Cookie.parse(setCookie[i]);\n      cookies.setCookieSync(cookie, url);\n    }\n  }\n\n}), {\n  get: function(dispatcher, allowed, disabled, callback, context) {\n    var endpoint = dispatcher.endpoint;\n\n    Faye.asyncEach(this._transports, function(pair, resume) {\n      var connType     = pair[0], klass = pair[1],\n          connEndpoint = dispatcher.endpointFor(connType);\n\n      if (Faye.indexOf(disabled, connType) >= 0)\n        return resume();\n\n      if (Faye.indexOf(allowed, connType) < 0) {\n        klass.isUsable(dispatcher, connEndpoint, function() {});\n        return resume();\n      }\n\n      klass.isUsable(dispatcher, connEndpoint, function(isUsable) {\n        if (!isUsable) return resume();\n        var transport = klass.hasOwnProperty('create') ? klass.create(dispatcher, connEndpoint) : new klass(dispatcher, connEndpoint);\n        callback.call(context, transport);\n      });\n    }, function() {\n      throw new Error('Could not find a usable connection type for ' + Faye.URI.stringify(endpoint));\n    });\n  },\n\n  register: function(type, klass) {\n    this._transports.push([type, klass]);\n    klass.prototype.connectionType = type;\n  },\n\n  getConnectionTypes: function() {\n    return Faye.map(this._transports, function(t) { return t[0] });\n  },\n\n  _transports: []\n});\n\nFaye.extend(Faye.Transport.prototype, Faye.Logging);\nFaye.extend(Faye.Transport.prototype, Faye.Timeouts);\n\nFaye.Event = {\n  _registry: [],\n\n  on: function(element, eventName, callback, context) {\n    var wrapped = function() { callback.call(context) };\n\n    if (element.addEventListener)\n      element.addEventListener(eventName, wrapped, false);\n    else\n      element.attachEvent('on' + eventName, wrapped);\n\n    this._registry.push({\n      _element:   element,\n      _type:      eventName,\n      _callback:  callback,\n      _context:     context,\n      _handler:   wrapped\n    });\n  },\n\n  detach: function(element, eventName, callback, context) {\n    var i = this._registry.length, register;\n    while (i--) {\n      register = this._registry[i];\n\n      if ((element    && element    !== register._element)   ||\n          (eventName  && eventName  !== register._type)      ||\n          (callback   && callback   !== register._callback)  ||\n          (context      && context      !== register._context))\n        continue;\n\n      if (register._element.removeEventListener)\n        register._element.removeEventListener(register._type, register._handler, false);\n      else\n        register._element.detachEvent('on' + register._type, register._handler);\n\n      this._registry.splice(i,1);\n      register = null;\n    }\n  }\n};\n\nif (Faye.ENV.onunload !== undefined) Faye.Event.on(Faye.ENV, 'unload', Faye.Event.detach, Faye.Event);\n\n/*\n    json2.js\n    2013-05-26\n\n    Public Domain.\n\n    NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.\n\n    See http://www.JSON.org/js.html\n\n\n    This code should be minified before deployment.\n    See http://javascript.crockford.com/jsmin.html\n\n    USE YOUR OWN COPY. IT IS EXTREMELY UNWISE TO LOAD CODE FROM SERVERS YOU DO\n    NOT CONTROL.\n\n\n    This file creates a global JSON object containing two methods: stringify\n    and parse.\n\n        JSON.stringify(value, replacer, space)\n            value       any JavaScript value, usually an object or array.\n\n            replacer    an optional parameter that determines how object\n                        values are stringified for objects. It can be a\n                        function or an array of strings.\n\n            space       an optional parameter that specifies the indentation\n                        of nested structures. If it is omitted, the text will\n                        be packed without extra whitespace. If it is a number,\n                        it will specify the number of spaces to indent at each\n                        level. If it is a string (such as '\\t' or '&nbsp;'),\n                        it contains the characters used to indent at each level.\n\n            This method produces a JSON text from a JavaScript value.\n\n            When an object value is found, if the object contains a toJSON\n            method, its toJSON method will be called and the result will be\n            stringified. A toJSON method does not serialize: it returns the\n            value represented by the name/value pair that should be serialized,\n            or undefined if nothing should be serialized. The toJSON method\n            will be passed the key associated with the value, and this will be\n            bound to the value\n\n            For example, this would serialize Dates as ISO strings.\n\n                Date.prototype.toJSON = function (key) {\n                    function f(n) {\n                        // Format integers to have at least two digits.\n                        return n < 10 ? '0' + n : n;\n                    }\n\n                    return this.getUTCFullYear()   + '-' +\n                         f(this.getUTCMonth() + 1) + '-' +\n                         f(this.getUTCDate())      + 'T' +\n                         f(this.getUTCHours())     + ':' +\n                         f(this.getUTCMinutes())   + ':' +\n                         f(this.getUTCSeconds())   + 'Z';\n                };\n\n            You can provide an optional replacer method. It will be passed the\n            key and value of each member, with this bound to the containing\n            object. The value that is returned from your method will be\n            serialized. If your method returns undefined, then the member will\n            be excluded from the serialization.\n\n            If the replacer parameter is an array of strings, then it will be\n            used to select the members to be serialized. It filters the results\n            such that only members with keys listed in the replacer array are\n            stringified.\n\n            Values that do not have JSON representations, such as undefined or\n            functions, will not be serialized. Such values in objects will be\n            dropped; in arrays they will be replaced with null. You can use\n            a replacer function to replace those with JSON values.\n            JSON.stringify(undefined) returns undefined.\n\n            The optional space parameter produces a stringification of the\n            value that is filled with line breaks and indentation to make it\n            easier to read.\n\n            If the space parameter is a non-empty string, then that string will\n            be used for indentation. If the space parameter is a number, then\n            the indentation will be that many spaces.\n\n            Example:\n\n            text = JSON.stringify(['e', {pluribus: 'unum'}]);\n            // text is '[\"e\",{\"pluribus\":\"unum\"}]'\n\n\n            text = JSON.stringify(['e', {pluribus: 'unum'}], null, '\\t');\n            // text is '[\\n\\t\"e\",\\n\\t{\\n\\t\\t\"pluribus\": \"unum\"\\n\\t}\\n]'\n\n            text = JSON.stringify([new Date()], function (key, value) {\n                return this[key] instanceof Date ?\n                    'Date(' + this[key] + ')' : value;\n            });\n            // text is '[\"Date(---current time---)\"]'\n\n\n        JSON.parse(text, reviver)\n            This method parses a JSON text to produce an object or array.\n            It can throw a SyntaxError exception.\n\n            The optional reviver parameter is a function that can filter and\n            transform the results. It receives each of the keys and values,\n            and its return value is used instead of the original value.\n            If it returns what it received, then the structure is not modified.\n            If it returns undefined then the member is deleted.\n\n            Example:\n\n            // Parse the text. Values that look like ISO date strings will\n            // be converted to Date objects.\n\n            myData = JSON.parse(text, function (key, value) {\n                var a;\n                if (typeof value === 'string') {\n                    a =\n/^(\\d{4})-(\\d{2})-(\\d{2})T(\\d{2}):(\\d{2}):(\\d{2}(?:\\.\\d*)?)Z$/.exec(value);\n                    if (a) {\n                        return new Date(Date.UTC(+a[1], +a[2] - 1, +a[3], +a[4],\n                            +a[5], +a[6]));\n                    }\n                }\n                return value;\n            });\n\n            myData = JSON.parse('[\"Date(09/09/2001)\"]', function (key, value) {\n                var d;\n                if (typeof value === 'string' &&\n                        value.slice(0, 5) === 'Date(' &&\n                        value.slice(-1) === ')') {\n                    d = new Date(value.slice(5, -1));\n                    if (d) {\n                        return d;\n                    }\n                }\n                return value;\n            });\n\n\n    This is a reference implementation. You are free to copy, modify, or\n    redistribute.\n*/\n\n/*jslint evil: true, regexp: true */\n\n/*members \"\", \"\\b\", \"\\t\", \"\\n\", \"\\f\", \"\\r\", \"\\\"\", JSON, \"\\\\\", apply,\n    call, charCodeAt, getUTCDate, getUTCFullYear, getUTCHours,\n    getUTCMinutes, getUTCMonth, getUTCSeconds, hasOwnProperty, join,\n    lastIndex, length, parse, prototype, push, replace, slice, stringify,\n    test, toJSON, toString, valueOf\n*/\n\n\n// Create a JSON object only if one does not already exist. We create the\n// methods in a closure to avoid creating global variables.\n\nif (typeof JSON !== 'object') {\n    JSON = {};\n}\n\n(function () {\n    'use strict';\n\n    function f(n) {\n        // Format integers to have at least two digits.\n        return n < 10 ? '0' + n : n;\n    }\n\n    if (typeof Date.prototype.toJSON !== 'function') {\n\n        Date.prototype.toJSON = function () {\n\n            return isFinite(this.valueOf())\n                ? this.getUTCFullYear()     + '-' +\n                    f(this.getUTCMonth() + 1) + '-' +\n                    f(this.getUTCDate())      + 'T' +\n                    f(this.getUTCHours())     + ':' +\n                    f(this.getUTCMinutes())   + ':' +\n                    f(this.getUTCSeconds())   + 'Z'\n                : null;\n        };\n\n        String.prototype.toJSON      =\n            Number.prototype.toJSON  =\n            Boolean.prototype.toJSON = function () {\n                return this.valueOf();\n            };\n    }\n\n    var cx = /[\\u0000\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n        escapable = /[\\\\\\\"\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n        gap,\n        indent,\n        meta = {    // table of character substitutions\n            '\\b': '\\\\b',\n            '\\t': '\\\\t',\n            '\\n': '\\\\n',\n            '\\f': '\\\\f',\n            '\\r': '\\\\r',\n            '\"' : '\\\\\"',\n            '\\\\': '\\\\\\\\'\n        },\n        rep;\n\n\n    function quote(string) {\n\n// If the string contains no control characters, no quote characters, and no\n// backslash characters, then we can safely slap some quotes around it.\n// Otherwise we must also replace the offending characters with safe escape\n// sequences.\n\n        escapable.lastIndex = 0;\n        return escapable.test(string) ? '\"' + string.replace(escapable, function (a) {\n            var c = meta[a];\n            return typeof c === 'string'\n                ? c\n                : '\\\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);\n        }) + '\"' : '\"' + string + '\"';\n    }\n\n\n    function str(key, holder) {\n\n// Produce a string from holder[key].\n\n        var i,          // The loop counter.\n            k,          // The member key.\n            v,          // The member value.\n            length,\n            mind = gap,\n            partial,\n            value = holder[key];\n\n// If the value has a toJSON method, call it to obtain a replacement value.\n\n        if (value && typeof value === 'object' &&\n                typeof value.toJSON === 'function') {\n            value = value.toJSON(key);\n        }\n\n// If we were called with a replacer function, then call the replacer to\n// obtain a replacement value.\n\n        if (typeof rep === 'function') {\n            value = rep.call(holder, key, value);\n        }\n\n// What happens next depends on the value's type.\n\n        switch (typeof value) {\n        case 'string':\n            return quote(value);\n\n        case 'number':\n\n// JSON numbers must be finite. Encode non-finite numbers as null.\n\n            return isFinite(value) ? String(value) : 'null';\n\n        case 'boolean':\n        case 'null':\n\n// If the value is a boolean or null, convert it to a string. Note:\n// typeof null does not produce 'null'. The case is included here in\n// the remote chance that this gets fixed someday.\n\n            return String(value);\n\n// If the type is 'object', we might be dealing with an object or an array or\n// null.\n\n        case 'object':\n\n// Due to a specification blunder in ECMAScript, typeof null is 'object',\n// so watch out for that case.\n\n            if (!value) {\n                return 'null';\n            }\n\n// Make an array to hold the partial results of stringifying this object value.\n\n            gap += indent;\n            partial = [];\n\n// Is the value an array?\n\n            if (Object.prototype.toString.apply(value) === '[object Array]') {\n\n// The value is an array. Stringify every element. Use null as a placeholder\n// for non-JSON values.\n\n                length = value.length;\n                for (i = 0; i < length; i += 1) {\n                    partial[i] = str(i, value) || 'null';\n                }\n\n// Join all of the elements together, separated with commas, and wrap them in\n// brackets.\n\n                v = partial.length === 0\n                    ? '[]'\n                    : gap\n                    ? '[\\n' + gap + partial.join(',\\n' + gap) + '\\n' + mind + ']'\n                    : '[' + partial.join(',') + ']';\n                gap = mind;\n                return v;\n            }\n\n// If the replacer is an array, use it to select the members to be stringified.\n\n            if (rep && typeof rep === 'object') {\n                length = rep.length;\n                for (i = 0; i < length; i += 1) {\n                    if (typeof rep[i] === 'string') {\n                        k = rep[i];\n                        v = str(k, value);\n                        if (v) {\n                            partial.push(quote(k) + (gap ? ': ' : ':') + v);\n                        }\n                    }\n                }\n            } else {\n\n// Otherwise, iterate through all of the keys in the object.\n\n                for (k in value) {\n                    if (Object.prototype.hasOwnProperty.call(value, k)) {\n                        v = str(k, value);\n                        if (v) {\n                            partial.push(quote(k) + (gap ? ': ' : ':') + v);\n                        }\n                    }\n                }\n            }\n\n// Join all of the member texts together, separated with commas,\n// and wrap them in braces.\n\n            v = partial.length === 0\n                ? '{}'\n                : gap\n                ? '{\\n' + gap + partial.join(',\\n' + gap) + '\\n' + mind + '}'\n                : '{' + partial.join(',') + '}';\n            gap = mind;\n            return v;\n        }\n    }\n\n// If the JSON object does not yet have a stringify method, give it one.\n\n    Faye.stringify = function (value, replacer, space) {\n\n// The stringify method takes a value and an optional replacer, and an optional\n// space parameter, and returns a JSON text. The replacer can be a function\n// that can replace values, or an array of strings that will select the keys.\n// A default replacer method can be provided. Use of the space parameter can\n// produce text that is more easily readable.\n\n        var i;\n        gap = '';\n        indent = '';\n\n// If the space parameter is a number, make an indent string containing that\n// many spaces.\n\n        if (typeof space === 'number') {\n            for (i = 0; i < space; i += 1) {\n                indent += ' ';\n            }\n\n// If the space parameter is a string, it will be used as the indent string.\n\n        } else if (typeof space === 'string') {\n            indent = space;\n        }\n\n// If there is a replacer, it must be a function or an array.\n// Otherwise, throw an error.\n\n        rep = replacer;\n        if (replacer && typeof replacer !== 'function' &&\n                (typeof replacer !== 'object' ||\n                typeof replacer.length !== 'number')) {\n            throw new Error('JSON.stringify');\n        }\n\n// Make a fake root object containing our value under the key of ''.\n// Return the result of stringifying the value.\n\n        return str('', {'': value});\n    };\n\n    if (typeof JSON.stringify !== 'function') {\n        JSON.stringify = Faye.stringify;\n    }\n\n// If the JSON object does not yet have a parse method, give it one.\n\n    if (typeof JSON.parse !== 'function') {\n        JSON.parse = function (text, reviver) {\n\n// The parse method takes a text and an optional reviver function, and returns\n// a JavaScript value if the text is a valid JSON text.\n\n            var j;\n\n            function walk(holder, key) {\n\n// The walk method is used to recursively walk the resulting structure so\n// that modifications can be made.\n\n                var k, v, value = holder[key];\n                if (value && typeof value === 'object') {\n                    for (k in value) {\n                        if (Object.prototype.hasOwnProperty.call(value, k)) {\n                            v = walk(value, k);\n                            if (v !== undefined) {\n                                value[k] = v;\n                            } else {\n                                delete value[k];\n                            }\n                        }\n                    }\n                }\n                return reviver.call(holder, key, value);\n            }\n\n\n// Parsing happens in four stages. In the first stage, we replace certain\n// Unicode characters with escape sequences. JavaScript handles many characters\n// incorrectly, either silently deleting them, or treating them as line endings.\n\n            text = String(text);\n            cx.lastIndex = 0;\n            if (cx.test(text)) {\n                text = text.replace(cx, function (a) {\n                    return '\\\\u' +\n                        ('0000' + a.charCodeAt(0).toString(16)).slice(-4);\n                });\n            }\n\n// In the second stage, we run the text against regular expressions that look\n// for non-JSON patterns. We are especially concerned with '()' and 'new'\n// because they can cause invocation, and '=' because it can cause mutation.\n// But just to be safe, we want to reject all unexpected forms.\n\n// We split the second stage into 4 regexp operations in order to work around\n// crippling inefficiencies in IE's and Safari's regexp engines. First we\n// replace the JSON backslash pairs with '@' (a non-JSON character). Second, we\n// replace all simple value tokens with ']' characters. Third, we delete all\n// open brackets that follow a colon or comma or that begin the text. Finally,\n// we look to see that the remaining characters are only whitespace or ']' or\n// ',' or ':' or '{' or '}'. If that is so, then the text is safe for eval.\n\n            if (/^[\\],:{}\\s]*$/\n                    .test(text.replace(/\\\\(?:[\"\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@')\n                        .replace(/\"[^\"\\\\\\n\\r]*\"|true|false|null|-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g, ']')\n                        .replace(/(?:^|:|,)(?:\\s*\\[)+/g, ''))) {\n\n// In the third stage we use the eval function to compile the text into a\n// JavaScript structure. The '{' operator is subject to a syntactic ambiguity\n// in JavaScript: it can begin a block or an object literal. We wrap the text\n// in parens to eliminate the ambiguity.\n\n                j = eval('(' + text + ')');\n\n// In the optional fourth stage, we recursively walk the new structure, passing\n// each name/value pair to a reviver function for possible transformation.\n\n                return typeof reviver === 'function'\n                    ? walk({'': j}, '')\n                    : j;\n            }\n\n// If the text is not JSON parseable, then a SyntaxError is thrown.\n\n            throw new SyntaxError('JSON.parse');\n        };\n    }\n}());\n\nFaye.Transport.WebSocket = Faye.extend(Faye.Class(Faye.Transport, {\n  UNCONNECTED:  1,\n  CONNECTING:   2,\n  CONNECTED:    3,\n\n  batching:     false,\n\n  isUsable: function(callback, context) {\n    this.callback(function() { callback.call(context, true) });\n    this.errback(function() { callback.call(context, false) });\n    this.connect();\n  },\n\n  request: function(messages) {\n    this._pending = this._pending || new Faye.Set();\n    for (var i = 0, n = messages.length; i < n; i++) this._pending.add(messages[i]);\n\n    var promise = new Faye.Promise();\n\n    this.callback(function(socket) {\n      if (!socket || socket.readyState !== 1) return;\n      socket.send(Faye.toJSON(messages));\n      Faye.Promise.fulfill(promise, socket);\n    }, this);\n\n    this.connect();\n\n    return {\n      abort: function() { promise.then(function(ws) { ws.close() }) }\n    };\n  },\n\n  connect: function() {\n    if (Faye.Transport.WebSocket._unloaded) return;\n\n    this._state = this._state || this.UNCONNECTED;\n    if (this._state !== this.UNCONNECTED) return;\n    this._state = this.CONNECTING;\n\n    var socket = this._createSocket();\n    if (!socket) return this.setDeferredStatus('failed');\n\n    var self = this;\n\n    socket.onopen = function() {\n      if (socket.headers) self._storeCookies(socket.headers['set-cookie']);\n      self._socket = socket;\n      self._state = self.CONNECTED;\n      self._everConnected = true;\n      self._ping();\n      self.setDeferredStatus('succeeded', socket);\n    };\n\n    var closed = false;\n    socket.onclose = socket.onerror = function() {\n      if (closed) return;\n      closed = true;\n\n      var wasConnected = (self._state === self.CONNECTED);\n      socket.onopen = socket.onclose = socket.onerror = socket.onmessage = null;\n\n      delete self._socket;\n      self._state = self.UNCONNECTED;\n      self.removeTimeout('ping');\n      self.setDeferredStatus('unknown');\n\n      var pending = self._pending ? self._pending.toArray() : [];\n      delete self._pending;\n\n      if (wasConnected) {\n        self._handleError(pending, true);\n      } else if (self._everConnected) {\n        self._handleError(pending);\n      } else {\n        self.setDeferredStatus('failed');\n      }\n    };\n\n    socket.onmessage = function(event) {\n      var replies = JSON.parse(event.data);\n      if (!replies) return;\n\n      replies = [].concat(replies);\n\n      for (var i = 0, n = replies.length; i < n; i++) {\n        if (replies[i].successful === undefined) continue;\n        self._pending.remove(replies[i]);\n      }\n      self._receive(replies);\n    };\n  },\n\n  close: function() {\n    if (!this._socket) return;\n    this._socket.close();\n  },\n\n  _createSocket: function() {\n    var url        = Faye.Transport.WebSocket.getSocketUrl(this.endpoint),\n        headers    = this._dispatcher.headers,\n        extensions = this._dispatcher.wsExtensions,\n        cookie     = this._getCookies(),\n        tls        = this._dispatcher.tls,\n        options    = {extensions: extensions, headers: headers, proxy: this._proxy, tls: tls};\n\n    if (cookie !== '') options.headers['Cookie'] = cookie;\n\n    if (Faye.WebSocket)        return new Faye.WebSocket.Client(url, [], options);\n    if (Faye.ENV.MozWebSocket) return new MozWebSocket(url);\n    if (Faye.ENV.WebSocket)    return new WebSocket(url);\n  },\n\n  _ping: function() {\n    if (!this._socket) return;\n    this._socket.send('[]');\n    this.addTimeout('ping', this._dispatcher.timeout / 2, this._ping, this);\n  }\n\n}), {\n  PROTOCOLS: {\n    'http:':  'ws:',\n    'https:': 'wss:'\n  },\n\n  create: function(dispatcher, endpoint) {\n    var sockets = dispatcher.transports.websocket = dispatcher.transports.websocket || {};\n    sockets[endpoint.href] = sockets[endpoint.href] || new this(dispatcher, endpoint);\n    return sockets[endpoint.href];\n  },\n\n  getSocketUrl: function(endpoint) {\n    endpoint = Faye.copyObject(endpoint);\n    endpoint.protocol = this.PROTOCOLS[endpoint.protocol];\n    return Faye.URI.stringify(endpoint);\n  },\n\n  isUsable: function(dispatcher, endpoint, callback, context) {\n    this.create(dispatcher, endpoint).isUsable(callback, context);\n  }\n});\n\nFaye.extend(Faye.Transport.WebSocket.prototype, Faye.Deferrable);\nFaye.Transport.register('websocket', Faye.Transport.WebSocket);\n\nif (Faye.Event && Faye.ENV.onbeforeunload !== undefined)\n  Faye.Event.on(Faye.ENV, 'beforeunload', function() {\n    Faye.Transport.WebSocket._unloaded = true;\n  });\n\nFaye.Transport.EventSource = Faye.extend(Faye.Class(Faye.Transport, {\n  initialize: function(dispatcher, endpoint) {\n    Faye.Transport.prototype.initialize.call(this, dispatcher, endpoint);\n    if (!Faye.ENV.EventSource) return this.setDeferredStatus('failed');\n\n    this._xhr = new Faye.Transport.XHR(dispatcher, endpoint);\n\n    endpoint = Faye.copyObject(endpoint);\n    endpoint.pathname += '/' + dispatcher.clientId;\n\n    var socket = new EventSource(Faye.URI.stringify(endpoint)),\n        self   = this;\n\n    socket.onopen = function() {\n      self._everConnected = true;\n      self.setDeferredStatus('succeeded');\n    };\n\n    socket.onerror = function() {\n      if (self._everConnected) {\n        self._handleError([]);\n      } else {\n        self.setDeferredStatus('failed');\n        socket.close();\n      }\n    };\n\n    socket.onmessage = function(event) {\n      self._receive(JSON.parse(event.data));\n    };\n\n    this._socket = socket;\n  },\n\n  close: function() {\n    if (!this._socket) return;\n    this._socket.onopen = this._socket.onerror = this._socket.onmessage = null;\n    this._socket.close();\n    delete this._socket;\n  },\n\n  isUsable: function(callback, context) {\n    this.callback(function() { callback.call(context, true) });\n    this.errback(function() { callback.call(context, false) });\n  },\n\n  encode: function(messages) {\n    return this._xhr.encode(messages);\n  },\n\n  request: function(messages) {\n    return this._xhr.request(messages);\n  }\n\n}), {\n  isUsable: function(dispatcher, endpoint, callback, context) {\n    var id = dispatcher.clientId;\n    if (!id) return callback.call(context, false);\n\n    Faye.Transport.XHR.isUsable(dispatcher, endpoint, function(usable) {\n      if (!usable) return callback.call(context, false);\n      this.create(dispatcher, endpoint).isUsable(callback, context);\n    }, this);\n  },\n\n  create: function(dispatcher, endpoint) {\n    var sockets = dispatcher.transports.eventsource = dispatcher.transports.eventsource || {},\n        id      = dispatcher.clientId;\n\n    var url = Faye.copyObject(endpoint);\n    url.pathname += '/' + (id || '');\n    url = Faye.URI.stringify(url);\n\n    sockets[url] = sockets[url] || new this(dispatcher, endpoint);\n    return sockets[url];\n  }\n});\n\nFaye.extend(Faye.Transport.EventSource.prototype, Faye.Deferrable);\nFaye.Transport.register('eventsource', Faye.Transport.EventSource);\n\nFaye.Transport.XHR = Faye.extend(Faye.Class(Faye.Transport, {\n  encode: function(messages) {\n    return Faye.toJSON(messages);\n  },\n\n  request: function(messages) {\n    var href = this.endpoint.href,\n        xhr  = Faye.ENV.ActiveXObject ? new ActiveXObject('Microsoft.XMLHTTP') : new XMLHttpRequest(),\n        self = this;\n\n    xhr.open('POST', href, true);\n    xhr.setRequestHeader('Content-Type', 'application/json');\n    xhr.setRequestHeader('Pragma', 'no-cache');\n    xhr.setRequestHeader('X-Requested-With', 'XMLHttpRequest');\n\n    var headers = this._dispatcher.headers;\n    for (var key in headers) {\n      if (!headers.hasOwnProperty(key)) continue;\n      xhr.setRequestHeader(key, headers[key]);\n    }\n\n    var abort = function() { xhr.abort() };\n    if (Faye.ENV.onbeforeunload !== undefined) Faye.Event.on(Faye.ENV, 'beforeunload', abort);\n\n    xhr.onreadystatechange = function() {\n      if (!xhr || xhr.readyState !== 4) return;\n\n      var replies    = null,\n          status     = xhr.status,\n          text       = xhr.responseText,\n          successful = (status >= 200 && status < 300) || status === 304 || status === 1223;\n\n      if (Faye.ENV.onbeforeunload !== undefined) Faye.Event.detach(Faye.ENV, 'beforeunload', abort);\n      xhr.onreadystatechange = function() {};\n      xhr = null;\n\n      if (!successful) return self._handleError(messages);\n\n      try {\n        replies = JSON.parse(text);\n      } catch (e) {}\n\n      if (replies)\n        self._receive(replies);\n      else\n        self._handleError(messages);\n    };\n\n    xhr.send(this.encode(messages));\n    return xhr;\n  }\n}), {\n  isUsable: function(dispatcher, endpoint, callback, context) {\n    callback.call(context, Faye.URI.isSameOrigin(endpoint));\n  }\n});\n\nFaye.Transport.register('long-polling', Faye.Transport.XHR);\n\nFaye.Transport.CORS = Faye.extend(Faye.Class(Faye.Transport, {\n  encode: function(messages) {\n    return 'message=' + encodeURIComponent(Faye.toJSON(messages));\n  },\n\n  request: function(messages) {\n    var xhrClass = Faye.ENV.XDomainRequest ? XDomainRequest : XMLHttpRequest,\n        xhr      = new xhrClass(),\n        id       = ++Faye.Transport.CORS._id,\n        headers  = this._dispatcher.headers,\n        self     = this,\n        key;\n\n    xhr.open('POST', Faye.URI.stringify(this.endpoint), true);\n\n    if (xhr.setRequestHeader) {\n      xhr.setRequestHeader('Pragma', 'no-cache');\n      for (key in headers) {\n        if (!headers.hasOwnProperty(key)) continue;\n        xhr.setRequestHeader(key, headers[key]);\n      }\n    }\n\n    var cleanUp = function() {\n      if (!xhr) return false;\n      Faye.Transport.CORS._pending.remove(id);\n      xhr.onload = xhr.onerror = xhr.ontimeout = xhr.onprogress = null;\n      xhr = null;\n    };\n\n    xhr.onload = function() {\n      var replies = null;\n      try {\n        replies = JSON.parse(xhr.responseText);\n      } catch (e) {}\n\n      cleanUp();\n\n      if (replies)\n        self._receive(replies);\n      else\n        self._handleError(messages);\n    };\n\n    xhr.onerror = xhr.ontimeout = function() {\n      cleanUp();\n      self._handleError(messages);\n    };\n\n    xhr.onprogress = function() {};\n\n    if (xhrClass === Faye.ENV.XDomainRequest)\n      Faye.Transport.CORS._pending.add({id: id, xhr: xhr});\n\n    xhr.send(this.encode(messages));\n    return xhr;\n  }\n}), {\n  _id:      0,\n  _pending: new Faye.Set(),\n\n  isUsable: function(dispatcher, endpoint, callback, context) {\n    if (Faye.URI.isSameOrigin(endpoint))\n      return callback.call(context, false);\n\n    if (Faye.ENV.XDomainRequest)\n      return callback.call(context, endpoint.protocol === Faye.ENV.location.protocol);\n\n    if (Faye.ENV.XMLHttpRequest) {\n      var xhr = new Faye.ENV.XMLHttpRequest();\n      return callback.call(context, xhr.withCredentials !== undefined);\n    }\n    return callback.call(context, false);\n  }\n});\n\nFaye.Transport.register('cross-origin-long-polling', Faye.Transport.CORS);\n\nFaye.Transport.JSONP = Faye.extend(Faye.Class(Faye.Transport, {\n encode: function(messages) {\n    var url = Faye.copyObject(this.endpoint);\n    url.query.message = Faye.toJSON(messages);\n    url.query.jsonp   = '__jsonp' + Faye.Transport.JSONP._cbCount + '__';\n    return Faye.URI.stringify(url);\n  },\n\n  request: function(messages) {\n    var head         = document.getElementsByTagName('head')[0],\n        script       = document.createElement('script'),\n        callbackName = Faye.Transport.JSONP.getCallbackName(),\n        endpoint     = Faye.copyObject(this.endpoint),\n        self         = this;\n\n    endpoint.query.message = Faye.toJSON(messages);\n    endpoint.query.jsonp   = callbackName;\n\n    var cleanup = function() {\n      if (!Faye.ENV[callbackName]) return false;\n      Faye.ENV[callbackName] = undefined;\n      try { delete Faye.ENV[callbackName] } catch (e) {}\n      script.parentNode.removeChild(script);\n    };\n\n    Faye.ENV[callbackName] = function(replies) {\n      cleanup();\n      self._receive(replies);\n    };\n\n    script.type = 'text/javascript';\n    script.src  = Faye.URI.stringify(endpoint);\n    head.appendChild(script);\n\n    script.onerror = function() {\n      cleanup();\n      self._handleError(messages);\n    };\n\n    return {abort: cleanup};\n  }\n}), {\n  _cbCount: 0,\n\n  getCallbackName: function() {\n    this._cbCount += 1;\n    return '__jsonp' + this._cbCount + '__';\n  },\n\n  isUsable: function(dispatcher, endpoint, callback, context) {\n    callback.call(context, true);\n  }\n});\n\nFaye.Transport.register('callback-polling', Faye.Transport.JSONP);\n\n})();\n}).call(this,require('_process'),typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"_process\":2}]},{},[1])(1)\n});\n\n","// shim for using process in browser\n\nvar process = module.exports = {};\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = setTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    clearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        setTimeout(drainQueue, 0);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","(function() {\n'use strict';\n\nvar Faye = {\n  VERSION:          '1.1.2',\n\n  BAYEUX_VERSION:   '1.0',\n  ID_LENGTH:        160,\n  JSONP_CALLBACK:   'jsonpcallback',\n  CONNECTION_TYPES: ['long-polling', 'cross-origin-long-polling', 'callback-polling', 'websocket', 'eventsource', 'in-process'],\n\n  MANDATORY_CONNECTION_TYPES: ['long-polling', 'callback-polling', 'in-process'],\n\n  ENV: (typeof window !== 'undefined') ? window : global,\n\n  extend: function(dest, source, overwrite) {\n    if (!source) return dest;\n    for (var key in source) {\n      if (!source.hasOwnProperty(key)) continue;\n      if (dest.hasOwnProperty(key) && overwrite === false) continue;\n      if (dest[key] !== source[key])\n        dest[key] = source[key];\n    }\n    return dest;\n  },\n\n  random: function(bitlength) {\n    bitlength = bitlength || this.ID_LENGTH;\n    var maxLength = Math.ceil(bitlength * Math.log(2) / Math.log(36));\n    var string = csprng(bitlength, 36);\n    while (string.length < maxLength) string = '0' + string;\n    return string;\n  },\n\n  validateOptions: function(options, validKeys) {\n    for (var key in options) {\n      if (this.indexOf(validKeys, key) < 0)\n        throw new Error('Unrecognized option: ' + key);\n    }\n  },\n\n  clientIdFromMessages: function(messages) {\n    var connect = this.filter([].concat(messages), function(message) {\n      return message.channel === '/meta/connect';\n    });\n    return connect[0] && connect[0].clientId;\n  },\n\n  copyObject: function(object) {\n    var clone, i, key;\n    if (object instanceof Array) {\n      clone = [];\n      i = object.length;\n      while (i--) clone[i] = Faye.copyObject(object[i]);\n      return clone;\n    } else if (typeof object === 'object') {\n      clone = (object === null) ? null : {};\n      for (key in object) clone[key] = Faye.copyObject(object[key]);\n      return clone;\n    } else {\n      return object;\n    }\n  },\n\n  commonElement: function(lista, listb) {\n    for (var i = 0, n = lista.length; i < n; i++) {\n      if (this.indexOf(listb, lista[i]) !== -1)\n        return lista[i];\n    }\n    return null;\n  },\n\n  indexOf: function(list, needle) {\n    if (list.indexOf) return list.indexOf(needle);\n\n    for (var i = 0, n = list.length; i < n; i++) {\n      if (list[i] === needle) return i;\n    }\n    return -1;\n  },\n\n  map: function(object, callback, context) {\n    if (object.map) return object.map(callback, context);\n    var result = [];\n\n    if (object instanceof Array) {\n      for (var i = 0, n = object.length; i < n; i++) {\n        result.push(callback.call(context || null, object[i], i));\n      }\n    } else {\n      for (var key in object) {\n        if (!object.hasOwnProperty(key)) continue;\n        result.push(callback.call(context || null, key, object[key]));\n      }\n    }\n    return result;\n  },\n\n  filter: function(array, callback, context) {\n    if (array.filter) return array.filter(callback, context);\n    var result = [];\n    for (var i = 0, n = array.length; i < n; i++) {\n      if (callback.call(context || null, array[i], i))\n        result.push(array[i]);\n    }\n    return result;\n  },\n\n  asyncEach: function(list, iterator, callback, context) {\n    var n       = list.length,\n        i       = -1,\n        calls   = 0,\n        looping = false;\n\n    var iterate = function() {\n      calls -= 1;\n      i += 1;\n      if (i === n) return callback && callback.call(context);\n      iterator(list[i], resume);\n    };\n\n    var loop = function() {\n      if (looping) return;\n      looping = true;\n      while (calls > 0) iterate();\n      looping = false;\n    };\n\n    var resume = function() {\n      calls += 1;\n      loop();\n    };\n    resume();\n  },\n\n  // http://assanka.net/content/tech/2009/09/02/json2-js-vs-prototype/\n  toJSON: function(object) {\n    if (!this.stringify) return JSON.stringify(object);\n\n    return this.stringify(object, function(key, value) {\n      return (this[key] instanceof Array) ? this[key] : value;\n    });\n  }\n};\n\nif (typeof module !== 'undefined')\n  module.exports = Faye;\nelse if (typeof window !== 'undefined')\n  window.Faye = Faye;\n\nFaye.Class = function(parent, methods) {\n  if (typeof parent !== 'function') {\n    methods = parent;\n    parent  = Object;\n  }\n\n  var klass = function() {\n    if (!this.initialize) return this;\n    return this.initialize.apply(this, arguments) || this;\n  };\n\n  var bridge = function() {};\n  bridge.prototype = parent.prototype;\n\n  klass.prototype = new bridge();\n  Faye.extend(klass.prototype, methods);\n\n  return klass;\n};\n\n(function() {\nvar EventEmitter = Faye.EventEmitter = function() {};\n\n/*\nCopyright Joyent, Inc. and other Node contributors. All rights reserved.\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\nof the Software, and to permit persons to whom the Software is furnished to do\nso, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\n\nvar isArray = typeof Array.isArray === 'function'\n    ? Array.isArray\n    : function (xs) {\n        return Object.prototype.toString.call(xs) === '[object Array]'\n    }\n;\nfunction indexOf (xs, x) {\n    if (xs.indexOf) return xs.indexOf(x);\n    for (var i = 0; i < xs.length; i++) {\n        if (x === xs[i]) return i;\n    }\n    return -1;\n}\n\n\nEventEmitter.prototype.emit = function(type) {\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events || !this._events.error ||\n        (isArray(this._events.error) && !this._events.error.length))\n    {\n      if (arguments[1] instanceof Error) {\n        throw arguments[1]; // Unhandled 'error' event\n      } else {\n        throw new Error(\"Uncaught, unspecified 'error' event.\");\n      }\n      return false;\n    }\n  }\n\n  if (!this._events) return false;\n  var handler = this._events[type];\n  if (!handler) return false;\n\n  if (typeof handler == 'function') {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        var args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n    return true;\n\n  } else if (isArray(handler)) {\n    var args = Array.prototype.slice.call(arguments, 1);\n\n    var listeners = handler.slice();\n    for (var i = 0, l = listeners.length; i < l; i++) {\n      listeners[i].apply(this, args);\n    }\n    return true;\n\n  } else {\n    return false;\n  }\n};\n\n// EventEmitter is defined in src/node_events.cc\n// EventEmitter.prototype.emit() is also defined there.\nEventEmitter.prototype.addListener = function(type, listener) {\n  if ('function' !== typeof listener) {\n    throw new Error('addListener only takes instances of Function');\n  }\n\n  if (!this._events) this._events = {};\n\n  // To avoid recursion in the case that type == \"newListeners\"! Before\n  // adding it to the listeners, first emit \"newListeners\".\n  this.emit('newListener', type, listener);\n\n  if (!this._events[type]) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  } else if (isArray(this._events[type])) {\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  } else {\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  var self = this;\n  self.on(type, function g() {\n    self.removeListener(type, g);\n    listener.apply(this, arguments);\n  });\n\n  return this;\n};\n\nEventEmitter.prototype.removeListener = function(type, listener) {\n  if ('function' !== typeof listener) {\n    throw new Error('removeListener only takes instances of Function');\n  }\n\n  // does not use listeners(), so no side effect of creating _events[type]\n  if (!this._events || !this._events[type]) return this;\n\n  var list = this._events[type];\n\n  if (isArray(list)) {\n    var i = indexOf(list, listener);\n    if (i < 0) return this;\n    list.splice(i, 1);\n    if (list.length == 0)\n      delete this._events[type];\n  } else if (this._events[type] === listener) {\n    delete this._events[type];\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  if (arguments.length === 0) {\n    this._events = {};\n    return this;\n  }\n\n  // does not use listeners(), so no side effect of creating _events[type]\n  if (type && this._events && this._events[type]) this._events[type] = null;\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  if (!this._events) this._events = {};\n  if (!this._events[type]) this._events[type] = [];\n  if (!isArray(this._events[type])) {\n    this._events[type] = [this._events[type]];\n  }\n  return this._events[type];\n};\n\n})();\n\nFaye.Namespace = Faye.Class({\n  initialize: function() {\n    this._used = {};\n  },\n\n  exists: function(id) {\n    return this._used.hasOwnProperty(id);\n  },\n\n  generate: function() {\n    var name = Faye.random();\n    while (this._used.hasOwnProperty(name))\n      name = Faye.random();\n    return this._used[name] = name;\n  },\n\n  release: function(id) {\n    delete this._used[id];\n  }\n});\n\n(function() {\n'use strict';\n\nvar timeout = setTimeout, defer;\n\nif (typeof setImmediate === 'function')\n  defer = function(fn) { setImmediate(fn) };\nelse if (typeof process === 'object' && process.nextTick)\n  defer = function(fn) { process.nextTick(fn) };\nelse\n  defer = function(fn) { timeout(fn, 0) };\n\nvar PENDING   = 0,\n    FULFILLED = 1,\n    REJECTED  = 2;\n\nvar RETURN = function(x) { return x },\n    THROW  = function(x) { throw  x };\n\nvar Promise = function(task) {\n  this._state       = PENDING;\n  this._onFulfilled = [];\n  this._onRejected  = [];\n\n  if (typeof task !== 'function') return;\n  var self = this;\n\n  task(function(value)  { fulfill(self, value) },\n       function(reason) { reject(self, reason) });\n};\n\nPromise.prototype.then = function(onFulfilled, onRejected) {\n  var next = new Promise();\n  registerOnFulfilled(this, onFulfilled, next);\n  registerOnRejected(this, onRejected, next);\n  return next;\n};\n\nvar registerOnFulfilled = function(promise, onFulfilled, next) {\n  if (typeof onFulfilled !== 'function') onFulfilled = RETURN;\n  var handler = function(value) { invoke(onFulfilled, value, next) };\n\n  if (promise._state === PENDING) {\n    promise._onFulfilled.push(handler);\n  } else if (promise._state === FULFILLED) {\n    handler(promise._value);\n  }\n};\n\nvar registerOnRejected = function(promise, onRejected, next) {\n  if (typeof onRejected !== 'function') onRejected = THROW;\n  var handler = function(reason) { invoke(onRejected, reason, next) };\n\n  if (promise._state === PENDING) {\n    promise._onRejected.push(handler);\n  } else if (promise._state === REJECTED) {\n    handler(promise._reason);\n  }\n};\n\nvar invoke = function(fn, value, next) {\n  defer(function() { _invoke(fn, value, next) });\n};\n\nvar _invoke = function(fn, value, next) {\n  var outcome;\n\n  try {\n    outcome = fn(value);\n  } catch (error) {\n    return reject(next, error);\n  }\n\n  if (outcome === next) {\n    reject(next, new TypeError('Recursive promise chain detected'));\n  } else {\n    fulfill(next, outcome);\n  }\n};\n\nvar fulfill = Promise.fulfill = Promise.resolve = function(promise, value) {\n  var called = false, type, then;\n\n  try {\n    type = typeof value;\n    then = value !== null && (type === 'function' || type === 'object') && value.then;\n\n    if (typeof then !== 'function') return _fulfill(promise, value);\n\n    then.call(value, function(v) {\n      if (!(called ^ (called = true))) return;\n      fulfill(promise, v);\n    }, function(r) {\n      if (!(called ^ (called = true))) return;\n      reject(promise, r);\n    });\n  } catch (error) {\n    if (!(called ^ (called = true))) return;\n    reject(promise, error);\n  }\n};\n\nvar _fulfill = function(promise, value) {\n  if (promise._state !== PENDING) return;\n\n  promise._state      = FULFILLED;\n  promise._value      = value;\n  promise._onRejected = [];\n\n  var onFulfilled = promise._onFulfilled, fn;\n  while (fn = onFulfilled.shift()) fn(value);\n};\n\nvar reject = Promise.reject = function(promise, reason) {\n  if (promise._state !== PENDING) return;\n\n  promise._state       = REJECTED;\n  promise._reason      = reason;\n  promise._onFulfilled = [];\n\n  var onRejected = promise._onRejected, fn;\n  while (fn = onRejected.shift()) fn(reason);\n};\n\nPromise.all = function(promises) {\n  return new Promise(function(fulfill, reject) {\n    var list = [],\n         n   = promises.length,\n         i;\n\n    if (n === 0) return fulfill(list);\n\n    for (i = 0; i < n; i++) (function(promise, i) {\n      Promise.fulfilled(promise).then(function(value) {\n        list[i] = value;\n        if (--n === 0) fulfill(list);\n      }, reject);\n    })(promises[i], i);\n  });\n};\n\nPromise.defer = defer;\n\nPromise.deferred = Promise.pending = function() {\n  var tuple = {};\n\n  tuple.promise = new Promise(function(fulfill, reject) {\n    tuple.fulfill = tuple.resolve = fulfill;\n    tuple.reject  = reject;\n  });\n  return tuple;\n};\n\nPromise.fulfilled = Promise.resolved = function(value) {\n  return new Promise(function(fulfill, reject) { fulfill(value) });\n};\n\nPromise.rejected = function(reason) {\n  return new Promise(function(fulfill, reject) { reject(reason) });\n};\n\nif (typeof Faye === 'undefined')\n  module.exports = Promise;\nelse\n  Faye.Promise = Promise;\n\n})();\n\nFaye.Set = Faye.Class({\n  initialize: function() {\n    this._index = {};\n  },\n\n  add: function(item) {\n    var key = (item.id !== undefined) ? item.id : item;\n    if (this._index.hasOwnProperty(key)) return false;\n    this._index[key] = item;\n    return true;\n  },\n\n  forEach: function(block, context) {\n    for (var key in this._index) {\n      if (this._index.hasOwnProperty(key))\n        block.call(context, this._index[key]);\n    }\n  },\n\n  isEmpty: function() {\n    for (var key in this._index) {\n      if (this._index.hasOwnProperty(key)) return false;\n    }\n    return true;\n  },\n\n  member: function(item) {\n    for (var key in this._index) {\n      if (this._index[key] === item) return true;\n    }\n    return false;\n  },\n\n  remove: function(item) {\n    var key = (item.id !== undefined) ? item.id : item;\n    var removed = this._index[key];\n    delete this._index[key];\n    return removed;\n  },\n\n  toArray: function() {\n    var array = [];\n    this.forEach(function(item) { array.push(item) });\n    return array;\n  }\n});\n\nFaye.URI = {\n  isURI: function(uri) {\n    return uri && uri.protocol && uri.host && uri.path;\n  },\n\n  isSameOrigin: function(uri) {\n    var location = Faye.ENV.location;\n    return uri.protocol === location.protocol &&\n           uri.hostname === location.hostname &&\n           uri.port     === location.port;\n  },\n\n  parse: function(url) {\n    if (typeof url !== 'string') return url;\n    var uri = {}, parts, query, pairs, i, n, data;\n\n    var consume = function(name, pattern) {\n      url = url.replace(pattern, function(match) {\n        uri[name] = match;\n        return '';\n      });\n      uri[name] = uri[name] || '';\n    };\n\n    consume('protocol', /^[a-z]+\\:/i);\n    consume('host',     /^\\/\\/[^\\/\\?#]+/);\n\n    if (!/^\\//.test(url) && !uri.host)\n      url = Faye.ENV.location.pathname.replace(/[^\\/]*$/, '') + url;\n\n    consume('pathname', /^[^\\?#]*/);\n    consume('search',   /^\\?[^#]*/);\n    consume('hash',     /^#.*/);\n\n    uri.protocol = uri.protocol || Faye.ENV.location.protocol;\n\n    if (uri.host) {\n      uri.host     = uri.host.substr(2);\n      parts        = uri.host.split(':');\n      uri.hostname = parts[0];\n      uri.port     = parts[1] || '';\n    } else {\n      uri.host     = Faye.ENV.location.host;\n      uri.hostname = Faye.ENV.location.hostname;\n      uri.port     = Faye.ENV.location.port;\n    }\n\n    uri.pathname = uri.pathname || '/';\n    uri.path = uri.pathname + uri.search;\n\n    query = uri.search.replace(/^\\?/, '');\n    pairs = query ? query.split('&') : [];\n    data  = {};\n\n    for (i = 0, n = pairs.length; i < n; i++) {\n      parts = pairs[i].split('=');\n      data[decodeURIComponent(parts[0] || '')] = decodeURIComponent(parts[1] || '');\n    }\n\n    uri.query = data;\n\n    uri.href = this.stringify(uri);\n    return uri;\n  },\n\n  stringify: function(uri) {\n    var string = uri.protocol + '//' + uri.hostname;\n    if (uri.port) string += ':' + uri.port;\n    string += uri.pathname + this.queryString(uri.query) + (uri.hash || '');\n    return string;\n  },\n\n  queryString: function(query) {\n    var pairs = [];\n    for (var key in query) {\n      if (!query.hasOwnProperty(key)) continue;\n      pairs.push(encodeURIComponent(key) + '=' + encodeURIComponent(query[key]));\n    }\n    if (pairs.length === 0) return '';\n    return '?' + pairs.join('&');\n  }\n};\n\nFaye.Error = Faye.Class({\n  initialize: function(code, params, message) {\n    this.code    = code;\n    this.params  = Array.prototype.slice.call(params);\n    this.message = message;\n  },\n\n  toString: function() {\n    return this.code + ':' +\n           this.params.join(',') + ':' +\n           this.message;\n  }\n});\n\nFaye.Error.parse = function(message) {\n  message = message || '';\n  if (!Faye.Grammar.ERROR.test(message)) return new this(null, [], message);\n\n  var parts   = message.split(':'),\n      code    = parseInt(parts[0]),\n      params  = parts[1].split(','),\n      message = parts[2];\n\n  return new this(code, params, message);\n};\n\n\n\n\nFaye.Error.versionMismatch = function() {\n  return new this(300, arguments, 'Version mismatch').toString();\n};\n\nFaye.Error.conntypeMismatch = function() {\n  return new this(301, arguments, 'Connection types not supported').toString();\n};\n\nFaye.Error.extMismatch = function() {\n  return new this(302, arguments, 'Extension mismatch').toString();\n};\n\nFaye.Error.badRequest = function() {\n  return new this(400, arguments, 'Bad request').toString();\n};\n\nFaye.Error.clientUnknown = function() {\n  return new this(401, arguments, 'Unknown client').toString();\n};\n\nFaye.Error.parameterMissing = function() {\n  return new this(402, arguments, 'Missing required parameter').toString();\n};\n\nFaye.Error.channelForbidden = function() {\n  return new this(403, arguments, 'Forbidden channel').toString();\n};\n\nFaye.Error.channelUnknown = function() {\n  return new this(404, arguments, 'Unknown channel').toString();\n};\n\nFaye.Error.channelInvalid = function() {\n  return new this(405, arguments, 'Invalid channel').toString();\n};\n\nFaye.Error.extUnknown = function() {\n  return new this(406, arguments, 'Unknown extension').toString();\n};\n\nFaye.Error.publishFailed = function() {\n  return new this(407, arguments, 'Failed to publish').toString();\n};\n\nFaye.Error.serverError = function() {\n  return new this(500, arguments, 'Internal server error').toString();\n};\n\n\nFaye.Deferrable = {\n  then: function(callback, errback) {\n    var self = this;\n    if (!this._promise)\n      this._promise = new Faye.Promise(function(fulfill, reject) {\n        self._fulfill = fulfill;\n        self._reject  = reject;\n      });\n\n    if (arguments.length === 0)\n      return this._promise;\n    else\n      return this._promise.then(callback, errback);\n  },\n\n  callback: function(callback, context) {\n    return this.then(function(value) { callback.call(context, value) });\n  },\n\n  errback: function(callback, context) {\n    return this.then(null, function(reason) { callback.call(context, reason) });\n  },\n\n  timeout: function(seconds, message) {\n    this.then();\n    var self = this;\n    this._timer = Faye.ENV.setTimeout(function() {\n      self._reject(message);\n    }, seconds * 1000);\n  },\n\n  setDeferredStatus: function(status, value) {\n    if (this._timer) Faye.ENV.clearTimeout(this._timer);\n\n    this.then();\n\n    if (status === 'succeeded')\n      this._fulfill(value);\n    else if (status === 'failed')\n      this._reject(value);\n    else\n      delete this._promise;\n  }\n};\n\nFaye.Publisher = {\n  countListeners: function(eventType) {\n    return this.listeners(eventType).length;\n  },\n\n  bind: function(eventType, listener, context) {\n    var slice   = Array.prototype.slice,\n        handler = function() { listener.apply(context, slice.call(arguments)) };\n\n    this._listeners = this._listeners || [];\n    this._listeners.push([eventType, listener, context, handler]);\n    return this.on(eventType, handler);\n  },\n\n  unbind: function(eventType, listener, context) {\n    this._listeners = this._listeners || [];\n    var n = this._listeners.length, tuple;\n\n    while (n--) {\n      tuple = this._listeners[n];\n      if (tuple[0] !== eventType) continue;\n      if (listener && (tuple[1] !== listener || tuple[2] !== context)) continue;\n      this._listeners.splice(n, 1);\n      this.removeListener(eventType, tuple[3]);\n    }\n  }\n};\n\nFaye.extend(Faye.Publisher, Faye.EventEmitter.prototype);\nFaye.Publisher.trigger = Faye.Publisher.emit;\n\nFaye.Timeouts = {\n  addTimeout: function(name, delay, callback, context) {\n    this._timeouts = this._timeouts || {};\n    if (this._timeouts.hasOwnProperty(name)) return;\n    var self = this;\n    this._timeouts[name] = Faye.ENV.setTimeout(function() {\n      delete self._timeouts[name];\n      callback.call(context);\n    }, 1000 * delay);\n  },\n\n  removeTimeout: function(name) {\n    this._timeouts = this._timeouts || {};\n    var timeout = this._timeouts[name];\n    if (!timeout) return;\n    Faye.ENV.clearTimeout(timeout);\n    delete this._timeouts[name];\n  },\n\n  removeAllTimeouts: function() {\n    this._timeouts = this._timeouts || {};\n    for (var name in this._timeouts) this.removeTimeout(name);\n  }\n};\n\nFaye.Logging = {\n  LOG_LEVELS: {\n    fatal:  4,\n    error:  3,\n    warn:   2,\n    info:   1,\n    debug:  0\n  },\n\n  writeLog: function(messageArgs, level) {\n    if (!Faye.logger) return;\n\n    var args   = Array.prototype.slice.apply(messageArgs),\n        banner = '[Faye',\n        klass  = this.className,\n\n        message = args.shift().replace(/\\?/g, function() {\n          try {\n            return Faye.toJSON(args.shift());\n          } catch (e) {\n            return '[Object]';\n          }\n        });\n\n    for (var key in Faye) {\n      if (klass) continue;\n      if (typeof Faye[key] !== 'function') continue;\n      if (this instanceof Faye[key]) klass = key;\n    }\n    if (klass) banner += '.' + klass;\n    banner += '] ';\n\n    if (typeof Faye.logger[level] === 'function')\n      Faye.logger[level](banner + message);\n    else if (typeof Faye.logger === 'function')\n      Faye.logger(banner + message);\n  }\n};\n\n(function() {\n  for (var key in Faye.Logging.LOG_LEVELS)\n    (function(level) {\n      Faye.Logging[level] = function() {\n        this.writeLog(arguments, level);\n      };\n    })(key);\n})();\n\nFaye.Grammar = {\n  CHANNEL_NAME:     /^\\/(((([a-z]|[A-Z])|[0-9])|(\\-|\\_|\\!|\\~|\\(|\\)|\\$|\\@)))+(\\/(((([a-z]|[A-Z])|[0-9])|(\\-|\\_|\\!|\\~|\\(|\\)|\\$|\\@)))+)*$/,\n  CHANNEL_PATTERN:  /^(\\/(((([a-z]|[A-Z])|[0-9])|(\\-|\\_|\\!|\\~|\\(|\\)|\\$|\\@)))+)*\\/\\*{1,2}$/,\n  ERROR:            /^([0-9][0-9][0-9]:(((([a-z]|[A-Z])|[0-9])|(\\-|\\_|\\!|\\~|\\(|\\)|\\$|\\@)| |\\/|\\*|\\.))*(,(((([a-z]|[A-Z])|[0-9])|(\\-|\\_|\\!|\\~|\\(|\\)|\\$|\\@)| |\\/|\\*|\\.))*)*:(((([a-z]|[A-Z])|[0-9])|(\\-|\\_|\\!|\\~|\\(|\\)|\\$|\\@)| |\\/|\\*|\\.))*|[0-9][0-9][0-9]::(((([a-z]|[A-Z])|[0-9])|(\\-|\\_|\\!|\\~|\\(|\\)|\\$|\\@)| |\\/|\\*|\\.))*)$/,\n  VERSION:          /^([0-9])+(\\.(([a-z]|[A-Z])|[0-9])(((([a-z]|[A-Z])|[0-9])|\\-|\\_))*)*$/\n};\n\nFaye.Extensible = {\n  addExtension: function(extension) {\n    this._extensions = this._extensions || [];\n    this._extensions.push(extension);\n    if (extension.added) extension.added(this);\n  },\n\n  removeExtension: function(extension) {\n    if (!this._extensions) return;\n    var i = this._extensions.length;\n    while (i--) {\n      if (this._extensions[i] !== extension) continue;\n      this._extensions.splice(i,1);\n      if (extension.removed) extension.removed(this);\n    }\n  },\n\n  pipeThroughExtensions: function(stage, message, request, callback, context) {\n    this.debug('Passing through ? extensions: ?', stage, message);\n\n    if (!this._extensions) return callback.call(context, message);\n    var extensions = this._extensions.slice();\n\n    var pipe = function(message) {\n      if (!message) return callback.call(context, message);\n\n      var extension = extensions.shift();\n      if (!extension) return callback.call(context, message);\n\n      var fn = extension[stage];\n      if (!fn) return pipe(message);\n\n      if (fn.length >= 3) extension[stage](message, request, pipe);\n      else                extension[stage](message, pipe);\n    };\n    pipe(message);\n  }\n};\n\nFaye.extend(Faye.Extensible, Faye.Logging);\n\nFaye.Channel = Faye.Class({\n  initialize: function(name) {\n    this.id = this.name = name;\n  },\n\n  push: function(message) {\n    this.trigger('message', message);\n  },\n\n  isUnused: function() {\n    return this.countListeners('message') === 0;\n  }\n});\n\nFaye.extend(Faye.Channel.prototype, Faye.Publisher);\n\nFaye.extend(Faye.Channel, {\n  HANDSHAKE:    '/meta/handshake',\n  CONNECT:      '/meta/connect',\n  SUBSCRIBE:    '/meta/subscribe',\n  UNSUBSCRIBE:  '/meta/unsubscribe',\n  DISCONNECT:   '/meta/disconnect',\n\n  META:         'meta',\n  SERVICE:      'service',\n\n  expand: function(name) {\n    var segments = this.parse(name),\n        channels = ['/**', name];\n\n    var copy = segments.slice();\n    copy[copy.length - 1] = '*';\n    channels.push(this.unparse(copy));\n\n    for (var i = 1, n = segments.length; i < n; i++) {\n      copy = segments.slice(0, i);\n      copy.push('**');\n      channels.push(this.unparse(copy));\n    }\n\n    return channels;\n  },\n\n  isValid: function(name) {\n    return Faye.Grammar.CHANNEL_NAME.test(name) ||\n           Faye.Grammar.CHANNEL_PATTERN.test(name);\n  },\n\n  parse: function(name) {\n    if (!this.isValid(name)) return null;\n    return name.split('/').slice(1);\n  },\n\n  unparse: function(segments) {\n    return '/' + segments.join('/');\n  },\n\n  isMeta: function(name) {\n    var segments = this.parse(name);\n    return segments ? (segments[0] === this.META) : null;\n  },\n\n  isService: function(name) {\n    var segments = this.parse(name);\n    return segments ? (segments[0] === this.SERVICE) : null;\n  },\n\n  isSubscribable: function(name) {\n    if (!this.isValid(name)) return null;\n    return !this.isMeta(name) && !this.isService(name);\n  },\n\n  Set: Faye.Class({\n    initialize: function() {\n      this._channels = {};\n    },\n\n    getKeys: function() {\n      var keys = [];\n      for (var key in this._channels) keys.push(key);\n      return keys;\n    },\n\n    remove: function(name) {\n      delete this._channels[name];\n    },\n\n    hasSubscription: function(name) {\n      return this._channels.hasOwnProperty(name);\n    },\n\n    subscribe: function(names, callback, context) {\n      var name;\n      for (var i = 0, n = names.length; i < n; i++) {\n        name = names[i];\n        var channel = this._channels[name] = this._channels[name] || new Faye.Channel(name);\n        if (callback) channel.bind('message', callback, context);\n      }\n    },\n\n    unsubscribe: function(name, callback, context) {\n      var channel = this._channels[name];\n      if (!channel) return false;\n      channel.unbind('message', callback, context);\n\n      if (channel.isUnused()) {\n        this.remove(name);\n        return true;\n      } else {\n        return false;\n      }\n    },\n\n    distributeMessage: function(message) {\n      var channels = Faye.Channel.expand(message.channel);\n\n      for (var i = 0, n = channels.length; i < n; i++) {\n        var channel = this._channels[channels[i]];\n        if (channel) channel.trigger('message', message.data);\n      }\n    }\n  })\n});\n\nFaye.Publication = Faye.Class(Faye.Deferrable);\n\nFaye.Subscription = Faye.Class({\n  initialize: function(client, channels, callback, context) {\n    this._client    = client;\n    this._channels  = channels;\n    this._callback  = callback;\n    this._context     = context;\n    this._cancelled = false;\n  },\n\n  cancel: function() {\n    if (this._cancelled) return;\n    this._client.unsubscribe(this._channels, this._callback, this._context);\n    this._cancelled = true;\n  },\n\n  unsubscribe: function() {\n    this.cancel();\n  }\n});\n\nFaye.extend(Faye.Subscription.prototype, Faye.Deferrable);\n\nFaye.Client = Faye.Class({\n  UNCONNECTED:        1,\n  CONNECTING:         2,\n  CONNECTED:          3,\n  DISCONNECTED:       4,\n\n  HANDSHAKE:          'handshake',\n  RETRY:              'retry',\n  NONE:               'none',\n\n  CONNECTION_TIMEOUT: 60,\n\n  DEFAULT_ENDPOINT:   '/bayeux',\n  INTERVAL:           0,\n\n  initialize: function(endpoint, options) {\n    this.info('New client created for ?', endpoint);\n    options = options || {};\n\n    Faye.validateOptions(options, ['interval', 'timeout', 'endpoints', 'proxy', 'retry', 'scheduler', 'websocketExtensions', 'tls', 'ca']);\n\n    this._endpoint   = endpoint || this.DEFAULT_ENDPOINT;\n    this._channels   = new Faye.Channel.Set();\n    this._dispatcher = new Faye.Dispatcher(this, this._endpoint, options);\n\n    this._messageId = 0;\n    this._state     = this.UNCONNECTED;\n\n    this._responseCallbacks = {};\n\n    this._advice = {\n      reconnect: this.RETRY,\n      interval:  1000 * (options.interval || this.INTERVAL),\n      timeout:   1000 * (options.timeout  || this.CONNECTION_TIMEOUT)\n    };\n    this._dispatcher.timeout = this._advice.timeout / 1000;\n\n    this._dispatcher.bind('message', this._receiveMessage, this);\n\n    if (Faye.Event && Faye.ENV.onbeforeunload !== undefined)\n      Faye.Event.on(Faye.ENV, 'beforeunload', function() {\n        if (Faye.indexOf(this._dispatcher._disabled, 'autodisconnect') < 0)\n          this.disconnect();\n      }, this);\n  },\n\n  addWebsocketExtension: function(extension) {\n    return this._dispatcher.addWebsocketExtension(extension);\n  },\n\n  disable: function(feature) {\n    return this._dispatcher.disable(feature);\n  },\n\n  setHeader: function(name, value) {\n    return this._dispatcher.setHeader(name, value);\n  },\n\n  // Request\n  // MUST include:  * channel\n  //                * version\n  //                * supportedConnectionTypes\n  // MAY include:   * minimumVersion\n  //                * ext\n  //                * id\n  //\n  // Success Response                             Failed Response\n  // MUST include:  * channel                     MUST include:  * channel\n  //                * version                                    * successful\n  //                * supportedConnectionTypes                   * error\n  //                * clientId                    MAY include:   * supportedConnectionTypes\n  //                * successful                                 * advice\n  // MAY include:   * minimumVersion                             * version\n  //                * advice                                     * minimumVersion\n  //                * ext                                        * ext\n  //                * id                                         * id\n  //                * authSuccessful\n  handshake: function(callback, context) {\n    if (this._advice.reconnect === this.NONE) return;\n    if (this._state !== this.UNCONNECTED) return;\n\n    this._state = this.CONNECTING;\n    var self = this;\n\n    this.info('Initiating handshake with ?', Faye.URI.stringify(this._endpoint));\n    this._dispatcher.selectTransport(Faye.MANDATORY_CONNECTION_TYPES);\n\n    this._sendMessage({\n      channel:                  Faye.Channel.HANDSHAKE,\n      version:                  Faye.BAYEUX_VERSION,\n      supportedConnectionTypes: this._dispatcher.getConnectionTypes()\n\n    }, {}, function(response) {\n\n      if (response.successful) {\n        this._state = this.CONNECTED;\n        this._dispatcher.clientId  = response.clientId;\n\n        this._dispatcher.selectTransport(response.supportedConnectionTypes);\n\n        this.info('Handshake successful: ?', this._dispatcher.clientId);\n\n        this.subscribe(this._channels.getKeys(), true);\n        if (callback) Faye.Promise.defer(function() { callback.call(context) });\n\n      } else {\n        this.info('Handshake unsuccessful');\n        Faye.ENV.setTimeout(function() { self.handshake(callback, context) }, this._dispatcher.retry * 1000);\n        this._state = this.UNCONNECTED;\n      }\n    }, this);\n  },\n\n  // Request                              Response\n  // MUST include:  * channel             MUST include:  * channel\n  //                * clientId                           * successful\n  //                * connectionType                     * clientId\n  // MAY include:   * ext                 MAY include:   * error\n  //                * id                                 * advice\n  //                                                     * ext\n  //                                                     * id\n  //                                                     * timestamp\n  connect: function(callback, context) {\n    if (this._advice.reconnect === this.NONE) return;\n    if (this._state === this.DISCONNECTED) return;\n\n    if (this._state === this.UNCONNECTED)\n      return this.handshake(function() { this.connect(callback, context) }, this);\n\n    this.callback(callback, context);\n    if (this._state !== this.CONNECTED) return;\n\n    this.info('Calling deferred actions for ?', this._dispatcher.clientId);\n    this.setDeferredStatus('succeeded');\n    this.setDeferredStatus('unknown');\n\n    if (this._connectRequest) return;\n    this._connectRequest = true;\n\n    this.info('Initiating connection for ?', this._dispatcher.clientId);\n\n    this._sendMessage({\n      channel:        Faye.Channel.CONNECT,\n      clientId:       this._dispatcher.clientId,\n      connectionType: this._dispatcher.connectionType\n\n    }, {}, this._cycleConnection, this);\n  },\n\n  // Request                              Response\n  // MUST include:  * channel             MUST include:  * channel\n  //                * clientId                           * successful\n  // MAY include:   * ext                                * clientId\n  //                * id                  MAY include:   * error\n  //                                                     * ext\n  //                                                     * id\n  disconnect: function() {\n    if (this._state !== this.CONNECTED) return;\n    this._state = this.DISCONNECTED;\n\n    this.info('Disconnecting ?', this._dispatcher.clientId);\n    var promise = new Faye.Publication();\n\n    this._sendMessage({\n      channel:  Faye.Channel.DISCONNECT,\n      clientId: this._dispatcher.clientId\n\n    }, {}, function(response) {\n      if (response.successful) {\n        this._dispatcher.close();\n        promise.setDeferredStatus('succeeded');\n      } else {\n        promise.setDeferredStatus('failed', Faye.Error.parse(response.error));\n      }\n    }, this);\n\n    this.info('Clearing channel listeners for ?', this._dispatcher.clientId);\n    this._channels = new Faye.Channel.Set();\n\n    return promise;\n  },\n\n  // Request                              Response\n  // MUST include:  * channel             MUST include:  * channel\n  //                * clientId                           * successful\n  //                * subscription                       * clientId\n  // MAY include:   * ext                                * subscription\n  //                * id                  MAY include:   * error\n  //                                                     * advice\n  //                                                     * ext\n  //                                                     * id\n  //                                                     * timestamp\n  subscribe: function(channel, callback, context) {\n    if (channel instanceof Array)\n      return Faye.map(channel, function(c) {\n        return this.subscribe(c, callback, context);\n      }, this);\n\n    var subscription = new Faye.Subscription(this, channel, callback, context),\n        force        = (callback === true),\n        hasSubscribe = this._channels.hasSubscription(channel);\n\n    if (hasSubscribe && !force) {\n      this._channels.subscribe([channel], callback, context);\n      subscription.setDeferredStatus('succeeded');\n      return subscription;\n    }\n\n    this.connect(function() {\n      this.info('Client ? attempting to subscribe to ?', this._dispatcher.clientId, channel);\n      if (!force) this._channels.subscribe([channel], callback, context);\n\n      this._sendMessage({\n        channel:      Faye.Channel.SUBSCRIBE,\n        clientId:     this._dispatcher.clientId,\n        subscription: channel\n\n      }, {}, function(response) {\n        if (!response.successful) {\n          subscription.setDeferredStatus('failed', Faye.Error.parse(response.error));\n          return this._channels.unsubscribe(channel, callback, context);\n        }\n\n        var channels = [].concat(response.subscription);\n        this.info('Subscription acknowledged for ? to ?', this._dispatcher.clientId, channels);\n        subscription.setDeferredStatus('succeeded');\n      }, this);\n    }, this);\n\n    return subscription;\n  },\n\n  // Request                              Response\n  // MUST include:  * channel             MUST include:  * channel\n  //                * clientId                           * successful\n  //                * subscription                       * clientId\n  // MAY include:   * ext                                * subscription\n  //                * id                  MAY include:   * error\n  //                                                     * advice\n  //                                                     * ext\n  //                                                     * id\n  //                                                     * timestamp\n  unsubscribe: function(channel, callback, context) {\n    if (channel instanceof Array)\n      return Faye.map(channel, function(c) {\n        return this.unsubscribe(c, callback, context);\n      }, this);\n\n    var dead = this._channels.unsubscribe(channel, callback, context);\n    if (!dead) return;\n\n    this.connect(function() {\n      this.info('Client ? attempting to unsubscribe from ?', this._dispatcher.clientId, channel);\n\n      this._sendMessage({\n        channel:      Faye.Channel.UNSUBSCRIBE,\n        clientId:     this._dispatcher.clientId,\n        subscription: channel\n\n      }, {}, function(response) {\n        if (!response.successful) return;\n\n        var channels = [].concat(response.subscription);\n        this.info('Unsubscription acknowledged for ? from ?', this._dispatcher.clientId, channels);\n      }, this);\n    }, this);\n  },\n\n  // Request                              Response\n  // MUST include:  * channel             MUST include:  * channel\n  //                * data                               * successful\n  // MAY include:   * clientId            MAY include:   * id\n  //                * id                                 * error\n  //                * ext                                * ext\n  publish: function(channel, data, options) {\n    Faye.validateOptions(options || {}, ['attempts', 'deadline']);\n    var publication = new Faye.Publication();\n\n    this.connect(function() {\n      this.info('Client ? queueing published message to ?: ?', this._dispatcher.clientId, channel, data);\n\n      this._sendMessage({\n        channel:  channel,\n        data:     data,\n        clientId: this._dispatcher.clientId\n\n      }, options, function(response) {\n        if (response.successful)\n          publication.setDeferredStatus('succeeded');\n        else\n          publication.setDeferredStatus('failed', Faye.Error.parse(response.error));\n      }, this);\n    }, this);\n\n    return publication;\n  },\n\n  _sendMessage: function(message, options, callback, context) {\n    message.id = this._generateMessageId();\n\n    var timeout = this._advice.timeout\n                ? 1.2 * this._advice.timeout / 1000\n                : 1.2 * this._dispatcher.retry;\n\n    this.pipeThroughExtensions('outgoing', message, null, function(message) {\n      if (!message) return;\n      if (callback) this._responseCallbacks[message.id] = [callback, context];\n      this._dispatcher.sendMessage(message, timeout, options || {});\n    }, this);\n  },\n\n  _generateMessageId: function() {\n    this._messageId += 1;\n    if (this._messageId >= Math.pow(2,32)) this._messageId = 0;\n    return this._messageId.toString(36);\n  },\n\n  _receiveMessage: function(message) {\n    var id = message.id, callback;\n\n    if (message.successful !== undefined) {\n      callback = this._responseCallbacks[id];\n      delete this._responseCallbacks[id];\n    }\n\n    this.pipeThroughExtensions('incoming', message, null, function(message) {\n      if (!message) return;\n      if (message.advice) this._handleAdvice(message.advice);\n      this._deliverMessage(message);\n      if (callback) callback[0].call(callback[1], message);\n    }, this);\n  },\n\n  _handleAdvice: function(advice) {\n    Faye.extend(this._advice, advice);\n    this._dispatcher.timeout = this._advice.timeout / 1000;\n\n    if (this._advice.reconnect === this.HANDSHAKE && this._state !== this.DISCONNECTED) {\n      this._state = this.UNCONNECTED;\n      this._dispatcher.clientId = null;\n      this._cycleConnection();\n    }\n  },\n\n  _deliverMessage: function(message) {\n    if (!message.channel || message.data === undefined) return;\n    this.info('Client ? calling listeners for ? with ?', this._dispatcher.clientId, message.channel, message.data);\n    this._channels.distributeMessage(message);\n  },\n\n  _cycleConnection: function() {\n    if (this._connectRequest) {\n      this._connectRequest = null;\n      this.info('Closed connection for ?', this._dispatcher.clientId);\n    }\n    var self = this;\n    Faye.ENV.setTimeout(function() { self.connect() }, this._advice.interval);\n  }\n});\n\nFaye.extend(Faye.Client.prototype, Faye.Deferrable);\nFaye.extend(Faye.Client.prototype, Faye.Publisher);\nFaye.extend(Faye.Client.prototype, Faye.Logging);\nFaye.extend(Faye.Client.prototype, Faye.Extensible);\n\nFaye.Dispatcher = Faye.Class({\n  MAX_REQUEST_SIZE: 2048,\n  DEFAULT_RETRY:    5,\n\n  UP:   1,\n  DOWN: 2,\n\n  initialize: function(client, endpoint, options) {\n    this._client     = client;\n    this.endpoint    = Faye.URI.parse(endpoint);\n    this._alternates = options.endpoints || {};\n\n    this.cookies      = Faye.Cookies && new Faye.Cookies.CookieJar();\n    this._disabled    = [];\n    this._envelopes   = {};\n    this.headers      = {};\n    this.retry        = options.retry || this.DEFAULT_RETRY;\n    this._scheduler   = options.scheduler || Faye.Scheduler;\n    this._state       = 0;\n    this.transports   = {};\n    this.wsExtensions = [];\n\n    this.proxy = options.proxy || {};\n    if (typeof this._proxy === 'string') this._proxy = {origin: this._proxy};\n\n    var exts = options.websocketExtensions;\n    if (exts) {\n      exts = [].concat(exts);\n      for (var i = 0, n = exts.length; i < n; i++)\n        this.addWebsocketExtension(exts[i]);\n    }\n\n    this.tls = options.tls || {};\n    this.tls.ca = this.tls.ca || options.ca;\n\n    for (var type in this._alternates)\n      this._alternates[type] = Faye.URI.parse(this._alternates[type]);\n\n    this.maxRequestSize = this.MAX_REQUEST_SIZE;\n  },\n\n  endpointFor: function(connectionType) {\n    return this._alternates[connectionType] || this.endpoint;\n  },\n\n  addWebsocketExtension: function(extension) {\n    this.wsExtensions.push(extension);\n  },\n\n  disable: function(feature) {\n    this._disabled.push(feature);\n  },\n\n  setHeader: function(name, value) {\n    this.headers[name] = value;\n  },\n\n  close: function() {\n    var transport = this._transport;\n    delete this._transport;\n    if (transport) transport.close();\n  },\n\n  getConnectionTypes: function() {\n    return Faye.Transport.getConnectionTypes();\n  },\n\n  selectTransport: function(transportTypes) {\n    Faye.Transport.get(this, transportTypes, this._disabled, function(transport) {\n      this.debug('Selected ? transport for ?', transport.connectionType, Faye.URI.stringify(transport.endpoint));\n\n      if (transport === this._transport) return;\n      if (this._transport) this._transport.close();\n\n      this._transport = transport;\n      this.connectionType = transport.connectionType;\n    }, this);\n  },\n\n  sendMessage: function(message, timeout, options) {\n    options = options || {};\n\n    var id       = message.id,\n        attempts = options.attempts,\n        deadline = options.deadline && new Date().getTime() + (options.deadline * 1000),\n        envelope = this._envelopes[id],\n        scheduler;\n\n    if (!envelope) {\n      scheduler = new this._scheduler(message, {timeout: timeout, interval: this.retry, attempts: attempts, deadline: deadline});\n      envelope  = this._envelopes[id] = {message: message, scheduler: scheduler};\n    }\n\n    this._sendEnvelope(envelope);\n  },\n\n  _sendEnvelope: function(envelope) {\n    if (!this._transport) return;\n    if (envelope.request || envelope.timer) return;\n\n    var message   = envelope.message,\n        scheduler = envelope.scheduler,\n        self      = this;\n\n    if (!scheduler.isDeliverable()) {\n      scheduler.abort();\n      delete this._envelopes[message.id];\n      return;\n    }\n\n    envelope.timer = Faye.ENV.setTimeout(function() {\n      self.handleError(message);\n    }, scheduler.getTimeout() * 1000);\n\n    scheduler.send();\n    envelope.request = this._transport.sendMessage(message);\n  },\n\n  handleResponse: function(reply) {\n    var envelope = this._envelopes[reply.id];\n\n    if (reply.successful !== undefined && envelope) {\n      envelope.scheduler.succeed();\n      delete this._envelopes[reply.id];\n      Faye.ENV.clearTimeout(envelope.timer);\n    }\n\n    this.trigger('message', reply);\n\n    if (this._state === this.UP) return;\n    this._state = this.UP;\n    this._client.trigger('transport:up');\n  },\n\n  handleError: function(message, immediate) {\n    var envelope = this._envelopes[message.id],\n        request  = envelope && envelope.request,\n        self     = this;\n\n    if (!request) return;\n\n    request.then(function(req) {\n      if (req && req.abort) req.abort();\n    });\n\n    var scheduler = envelope.scheduler;\n    scheduler.fail();\n\n    Faye.ENV.clearTimeout(envelope.timer);\n    envelope.request = envelope.timer = null;\n\n    if (immediate) {\n      this._sendEnvelope(envelope);\n    } else {\n      envelope.timer = Faye.ENV.setTimeout(function() {\n        envelope.timer = null;\n        self._sendEnvelope(envelope);\n      }, scheduler.getInterval() * 1000);\n    }\n\n    if (this._state === this.DOWN) return;\n    this._state = this.DOWN;\n    this._client.trigger('transport:down');\n  }\n});\n\nFaye.extend(Faye.Dispatcher.prototype, Faye.Publisher);\nFaye.extend(Faye.Dispatcher.prototype, Faye.Logging);\n\nFaye.Scheduler = function(message, options) {\n  this.message  = message;\n  this.options  = options;\n  this.attempts = 0;\n};\n\nFaye.extend(Faye.Scheduler.prototype, {\n  getTimeout: function() {\n    return this.options.timeout;\n  },\n\n  getInterval: function() {\n    return this.options.interval;\n  },\n\n  isDeliverable: function() {\n    var attempts = this.options.attempts,\n        made     = this.attempts,\n        deadline = this.options.deadline,\n        now      = new Date().getTime();\n\n    if (attempts !== undefined && made >= attempts)\n      return false;\n\n    if (deadline !== undefined && now > deadline)\n      return false;\n\n    return true;\n  },\n\n  send: function() {\n    this.attempts += 1;\n  },\n\n  succeed: function() {},\n\n  fail: function() {},\n\n  abort: function() {}\n});\n\nFaye.Transport = Faye.extend(Faye.Class({\n  DEFAULT_PORTS:    {'http:': 80, 'https:': 443, 'ws:': 80, 'wss:': 443},\n  SECURE_PROTOCOLS: ['https:', 'wss:'],\n  MAX_DELAY:        0,\n\n  batching:  true,\n\n  initialize: function(dispatcher, endpoint) {\n    this._dispatcher = dispatcher;\n    this.endpoint    = endpoint;\n    this._outbox     = [];\n    this._proxy      = Faye.extend({}, this._dispatcher.proxy);\n\n    if (!this._proxy.origin && Faye.NodeAdapter) {\n      this._proxy.origin = Faye.indexOf(this.SECURE_PROTOCOLS, this.endpoint.protocol) >= 0\n                         ? (process.env.HTTPS_PROXY || process.env.https_proxy)\n                         : (process.env.HTTP_PROXY  || process.env.http_proxy);\n    }\n  },\n\n  close: function() {},\n\n  encode: function(messages) {\n    return '';\n  },\n\n  sendMessage: function(message) {\n    this.debug('Client ? sending message to ?: ?',\n               this._dispatcher.clientId, Faye.URI.stringify(this.endpoint), message);\n\n    if (!this.batching) return Faye.Promise.fulfilled(this.request([message]));\n\n    this._outbox.push(message);\n    this._promise = this._promise || new Faye.Promise();\n    this._flushLargeBatch();\n\n    if (message.channel === Faye.Channel.HANDSHAKE) {\n      this.addTimeout('publish', 0.01, this._flush, this);\n      return this._promise;\n    }\n\n    if (message.channel === Faye.Channel.CONNECT)\n      this._connectMessage = message;\n\n    this.addTimeout('publish', this.MAX_DELAY, this._flush, this);\n    return this._promise;\n  },\n\n  _flush: function() {\n    this.removeTimeout('publish');\n\n    if (this._outbox.length > 1 && this._connectMessage)\n      this._connectMessage.advice = {timeout: 0};\n\n    Faye.Promise.fulfill(this._promise, this.request(this._outbox));\n    delete this._promise;\n\n    this._connectMessage = null;\n    this._outbox = [];\n  },\n\n  _flushLargeBatch: function() {\n    var string = this.encode(this._outbox);\n    if (string.length < this._dispatcher.maxRequestSize) return;\n    var last = this._outbox.pop();\n    this._flush();\n    if (last) this._outbox.push(last);\n  },\n\n  _receive: function(replies) {\n    if (!replies) return;\n    replies = [].concat(replies);\n\n    this.debug('Client ? received from ? via ?: ?',\n               this._dispatcher.clientId, Faye.URI.stringify(this.endpoint), this.connectionType, replies);\n\n    for (var i = 0, n = replies.length; i < n; i++)\n      this._dispatcher.handleResponse(replies[i]);\n  },\n\n  _handleError: function(messages, immediate) {\n    messages = [].concat(messages);\n\n    this.debug('Client ? failed to send to ? via ?: ?',\n               this._dispatcher.clientId, Faye.URI.stringify(this.endpoint), this.connectionType, messages);\n\n    for (var i = 0, n = messages.length; i < n; i++)\n      this._dispatcher.handleError(messages[i]);\n  },\n\n  _getCookies: function() {\n    var cookies = this._dispatcher.cookies,\n        url     = Faye.URI.stringify(this.endpoint);\n\n    if (!cookies) return '';\n\n    return Faye.map(cookies.getCookiesSync(url), function(cookie) {\n      return cookie.cookieString();\n    }).join('; ');\n  },\n\n  _storeCookies: function(setCookie) {\n    var cookies = this._dispatcher.cookies,\n        url     = Faye.URI.stringify(this.endpoint),\n        cookie;\n\n    if (!setCookie || !cookies) return;\n    setCookie = [].concat(setCookie);\n\n    for (var i = 0, n = setCookie.length; i < n; i++) {\n      cookie = Faye.Cookies.Cookie.parse(setCookie[i]);\n      cookies.setCookieSync(cookie, url);\n    }\n  }\n\n}), {\n  get: function(dispatcher, allowed, disabled, callback, context) {\n    var endpoint = dispatcher.endpoint;\n\n    Faye.asyncEach(this._transports, function(pair, resume) {\n      var connType     = pair[0], klass = pair[1],\n          connEndpoint = dispatcher.endpointFor(connType);\n\n      if (Faye.indexOf(disabled, connType) >= 0)\n        return resume();\n\n      if (Faye.indexOf(allowed, connType) < 0) {\n        klass.isUsable(dispatcher, connEndpoint, function() {});\n        return resume();\n      }\n\n      klass.isUsable(dispatcher, connEndpoint, function(isUsable) {\n        if (!isUsable) return resume();\n        var transport = klass.hasOwnProperty('create') ? klass.create(dispatcher, connEndpoint) : new klass(dispatcher, connEndpoint);\n        callback.call(context, transport);\n      });\n    }, function() {\n      throw new Error('Could not find a usable connection type for ' + Faye.URI.stringify(endpoint));\n    });\n  },\n\n  register: function(type, klass) {\n    this._transports.push([type, klass]);\n    klass.prototype.connectionType = type;\n  },\n\n  getConnectionTypes: function() {\n    return Faye.map(this._transports, function(t) { return t[0] });\n  },\n\n  _transports: []\n});\n\nFaye.extend(Faye.Transport.prototype, Faye.Logging);\nFaye.extend(Faye.Transport.prototype, Faye.Timeouts);\n\nFaye.Event = {\n  _registry: [],\n\n  on: function(element, eventName, callback, context) {\n    var wrapped = function() { callback.call(context) };\n\n    if (element.addEventListener)\n      element.addEventListener(eventName, wrapped, false);\n    else\n      element.attachEvent('on' + eventName, wrapped);\n\n    this._registry.push({\n      _element:   element,\n      _type:      eventName,\n      _callback:  callback,\n      _context:     context,\n      _handler:   wrapped\n    });\n  },\n\n  detach: function(element, eventName, callback, context) {\n    var i = this._registry.length, register;\n    while (i--) {\n      register = this._registry[i];\n\n      if ((element    && element    !== register._element)   ||\n          (eventName  && eventName  !== register._type)      ||\n          (callback   && callback   !== register._callback)  ||\n          (context      && context      !== register._context))\n        continue;\n\n      if (register._element.removeEventListener)\n        register._element.removeEventListener(register._type, register._handler, false);\n      else\n        register._element.detachEvent('on' + register._type, register._handler);\n\n      this._registry.splice(i,1);\n      register = null;\n    }\n  }\n};\n\nif (Faye.ENV.onunload !== undefined) Faye.Event.on(Faye.ENV, 'unload', Faye.Event.detach, Faye.Event);\n\n/*\n    json2.js\n    2013-05-26\n\n    Public Domain.\n\n    NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.\n\n    See http://www.JSON.org/js.html\n\n\n    This code should be minified before deployment.\n    See http://javascript.crockford.com/jsmin.html\n\n    USE YOUR OWN COPY. IT IS EXTREMELY UNWISE TO LOAD CODE FROM SERVERS YOU DO\n    NOT CONTROL.\n\n\n    This file creates a global JSON object containing two methods: stringify\n    and parse.\n\n        JSON.stringify(value, replacer, space)\n            value       any JavaScript value, usually an object or array.\n\n            replacer    an optional parameter that determines how object\n                        values are stringified for objects. It can be a\n                        function or an array of strings.\n\n            space       an optional parameter that specifies the indentation\n                        of nested structures. If it is omitted, the text will\n                        be packed without extra whitespace. If it is a number,\n                        it will specify the number of spaces to indent at each\n                        level. If it is a string (such as '\\t' or '&nbsp;'),\n                        it contains the characters used to indent at each level.\n\n            This method produces a JSON text from a JavaScript value.\n\n            When an object value is found, if the object contains a toJSON\n            method, its toJSON method will be called and the result will be\n            stringified. A toJSON method does not serialize: it returns the\n            value represented by the name/value pair that should be serialized,\n            or undefined if nothing should be serialized. The toJSON method\n            will be passed the key associated with the value, and this will be\n            bound to the value\n\n            For example, this would serialize Dates as ISO strings.\n\n                Date.prototype.toJSON = function (key) {\n                    function f(n) {\n                        // Format integers to have at least two digits.\n                        return n < 10 ? '0' + n : n;\n                    }\n\n                    return this.getUTCFullYear()   + '-' +\n                         f(this.getUTCMonth() + 1) + '-' +\n                         f(this.getUTCDate())      + 'T' +\n                         f(this.getUTCHours())     + ':' +\n                         f(this.getUTCMinutes())   + ':' +\n                         f(this.getUTCSeconds())   + 'Z';\n                };\n\n            You can provide an optional replacer method. It will be passed the\n            key and value of each member, with this bound to the containing\n            object. The value that is returned from your method will be\n            serialized. If your method returns undefined, then the member will\n            be excluded from the serialization.\n\n            If the replacer parameter is an array of strings, then it will be\n            used to select the members to be serialized. It filters the results\n            such that only members with keys listed in the replacer array are\n            stringified.\n\n            Values that do not have JSON representations, such as undefined or\n            functions, will not be serialized. Such values in objects will be\n            dropped; in arrays they will be replaced with null. You can use\n            a replacer function to replace those with JSON values.\n            JSON.stringify(undefined) returns undefined.\n\n            The optional space parameter produces a stringification of the\n            value that is filled with line breaks and indentation to make it\n            easier to read.\n\n            If the space parameter is a non-empty string, then that string will\n            be used for indentation. If the space parameter is a number, then\n            the indentation will be that many spaces.\n\n            Example:\n\n            text = JSON.stringify(['e', {pluribus: 'unum'}]);\n            // text is '[\"e\",{\"pluribus\":\"unum\"}]'\n\n\n            text = JSON.stringify(['e', {pluribus: 'unum'}], null, '\\t');\n            // text is '[\\n\\t\"e\",\\n\\t{\\n\\t\\t\"pluribus\": \"unum\"\\n\\t}\\n]'\n\n            text = JSON.stringify([new Date()], function (key, value) {\n                return this[key] instanceof Date ?\n                    'Date(' + this[key] + ')' : value;\n            });\n            // text is '[\"Date(---current time---)\"]'\n\n\n        JSON.parse(text, reviver)\n            This method parses a JSON text to produce an object or array.\n            It can throw a SyntaxError exception.\n\n            The optional reviver parameter is a function that can filter and\n            transform the results. It receives each of the keys and values,\n            and its return value is used instead of the original value.\n            If it returns what it received, then the structure is not modified.\n            If it returns undefined then the member is deleted.\n\n            Example:\n\n            // Parse the text. Values that look like ISO date strings will\n            // be converted to Date objects.\n\n            myData = JSON.parse(text, function (key, value) {\n                var a;\n                if (typeof value === 'string') {\n                    a =\n/^(\\d{4})-(\\d{2})-(\\d{2})T(\\d{2}):(\\d{2}):(\\d{2}(?:\\.\\d*)?)Z$/.exec(value);\n                    if (a) {\n                        return new Date(Date.UTC(+a[1], +a[2] - 1, +a[3], +a[4],\n                            +a[5], +a[6]));\n                    }\n                }\n                return value;\n            });\n\n            myData = JSON.parse('[\"Date(09/09/2001)\"]', function (key, value) {\n                var d;\n                if (typeof value === 'string' &&\n                        value.slice(0, 5) === 'Date(' &&\n                        value.slice(-1) === ')') {\n                    d = new Date(value.slice(5, -1));\n                    if (d) {\n                        return d;\n                    }\n                }\n                return value;\n            });\n\n\n    This is a reference implementation. You are free to copy, modify, or\n    redistribute.\n*/\n\n/*jslint evil: true, regexp: true */\n\n/*members \"\", \"\\b\", \"\\t\", \"\\n\", \"\\f\", \"\\r\", \"\\\"\", JSON, \"\\\\\", apply,\n    call, charCodeAt, getUTCDate, getUTCFullYear, getUTCHours,\n    getUTCMinutes, getUTCMonth, getUTCSeconds, hasOwnProperty, join,\n    lastIndex, length, parse, prototype, push, replace, slice, stringify,\n    test, toJSON, toString, valueOf\n*/\n\n\n// Create a JSON object only if one does not already exist. We create the\n// methods in a closure to avoid creating global variables.\n\nif (typeof JSON !== 'object') {\n    JSON = {};\n}\n\n(function () {\n    'use strict';\n\n    function f(n) {\n        // Format integers to have at least two digits.\n        return n < 10 ? '0' + n : n;\n    }\n\n    if (typeof Date.prototype.toJSON !== 'function') {\n\n        Date.prototype.toJSON = function () {\n\n            return isFinite(this.valueOf())\n                ? this.getUTCFullYear()     + '-' +\n                    f(this.getUTCMonth() + 1) + '-' +\n                    f(this.getUTCDate())      + 'T' +\n                    f(this.getUTCHours())     + ':' +\n                    f(this.getUTCMinutes())   + ':' +\n                    f(this.getUTCSeconds())   + 'Z'\n                : null;\n        };\n\n        String.prototype.toJSON      =\n            Number.prototype.toJSON  =\n            Boolean.prototype.toJSON = function () {\n                return this.valueOf();\n            };\n    }\n\n    var cx = /[\\u0000\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n        escapable = /[\\\\\\\"\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n        gap,\n        indent,\n        meta = {    // table of character substitutions\n            '\\b': '\\\\b',\n            '\\t': '\\\\t',\n            '\\n': '\\\\n',\n            '\\f': '\\\\f',\n            '\\r': '\\\\r',\n            '\"' : '\\\\\"',\n            '\\\\': '\\\\\\\\'\n        },\n        rep;\n\n\n    function quote(string) {\n\n// If the string contains no control characters, no quote characters, and no\n// backslash characters, then we can safely slap some quotes around it.\n// Otherwise we must also replace the offending characters with safe escape\n// sequences.\n\n        escapable.lastIndex = 0;\n        return escapable.test(string) ? '\"' + string.replace(escapable, function (a) {\n            var c = meta[a];\n            return typeof c === 'string'\n                ? c\n                : '\\\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);\n        }) + '\"' : '\"' + string + '\"';\n    }\n\n\n    function str(key, holder) {\n\n// Produce a string from holder[key].\n\n        var i,          // The loop counter.\n            k,          // The member key.\n            v,          // The member value.\n            length,\n            mind = gap,\n            partial,\n            value = holder[key];\n\n// If the value has a toJSON method, call it to obtain a replacement value.\n\n        if (value && typeof value === 'object' &&\n                typeof value.toJSON === 'function') {\n            value = value.toJSON(key);\n        }\n\n// If we were called with a replacer function, then call the replacer to\n// obtain a replacement value.\n\n        if (typeof rep === 'function') {\n            value = rep.call(holder, key, value);\n        }\n\n// What happens next depends on the value's type.\n\n        switch (typeof value) {\n        case 'string':\n            return quote(value);\n\n        case 'number':\n\n// JSON numbers must be finite. Encode non-finite numbers as null.\n\n            return isFinite(value) ? String(value) : 'null';\n\n        case 'boolean':\n        case 'null':\n\n// If the value is a boolean or null, convert it to a string. Note:\n// typeof null does not produce 'null'. The case is included here in\n// the remote chance that this gets fixed someday.\n\n            return String(value);\n\n// If the type is 'object', we might be dealing with an object or an array or\n// null.\n\n        case 'object':\n\n// Due to a specification blunder in ECMAScript, typeof null is 'object',\n// so watch out for that case.\n\n            if (!value) {\n                return 'null';\n            }\n\n// Make an array to hold the partial results of stringifying this object value.\n\n            gap += indent;\n            partial = [];\n\n// Is the value an array?\n\n            if (Object.prototype.toString.apply(value) === '[object Array]') {\n\n// The value is an array. Stringify every element. Use null as a placeholder\n// for non-JSON values.\n\n                length = value.length;\n                for (i = 0; i < length; i += 1) {\n                    partial[i] = str(i, value) || 'null';\n                }\n\n// Join all of the elements together, separated with commas, and wrap them in\n// brackets.\n\n                v = partial.length === 0\n                    ? '[]'\n                    : gap\n                    ? '[\\n' + gap + partial.join(',\\n' + gap) + '\\n' + mind + ']'\n                    : '[' + partial.join(',') + ']';\n                gap = mind;\n                return v;\n            }\n\n// If the replacer is an array, use it to select the members to be stringified.\n\n            if (rep && typeof rep === 'object') {\n                length = rep.length;\n                for (i = 0; i < length; i += 1) {\n                    if (typeof rep[i] === 'string') {\n                        k = rep[i];\n                        v = str(k, value);\n                        if (v) {\n                            partial.push(quote(k) + (gap ? ': ' : ':') + v);\n                        }\n                    }\n                }\n            } else {\n\n// Otherwise, iterate through all of the keys in the object.\n\n                for (k in value) {\n                    if (Object.prototype.hasOwnProperty.call(value, k)) {\n                        v = str(k, value);\n                        if (v) {\n                            partial.push(quote(k) + (gap ? ': ' : ':') + v);\n                        }\n                    }\n                }\n            }\n\n// Join all of the member texts together, separated with commas,\n// and wrap them in braces.\n\n            v = partial.length === 0\n                ? '{}'\n                : gap\n                ? '{\\n' + gap + partial.join(',\\n' + gap) + '\\n' + mind + '}'\n                : '{' + partial.join(',') + '}';\n            gap = mind;\n            return v;\n        }\n    }\n\n// If the JSON object does not yet have a stringify method, give it one.\n\n    Faye.stringify = function (value, replacer, space) {\n\n// The stringify method takes a value and an optional replacer, and an optional\n// space parameter, and returns a JSON text. The replacer can be a function\n// that can replace values, or an array of strings that will select the keys.\n// A default replacer method can be provided. Use of the space parameter can\n// produce text that is more easily readable.\n\n        var i;\n        gap = '';\n        indent = '';\n\n// If the space parameter is a number, make an indent string containing that\n// many spaces.\n\n        if (typeof space === 'number') {\n            for (i = 0; i < space; i += 1) {\n                indent += ' ';\n            }\n\n// If the space parameter is a string, it will be used as the indent string.\n\n        } else if (typeof space === 'string') {\n            indent = space;\n        }\n\n// If there is a replacer, it must be a function or an array.\n// Otherwise, throw an error.\n\n        rep = replacer;\n        if (replacer && typeof replacer !== 'function' &&\n                (typeof replacer !== 'object' ||\n                typeof replacer.length !== 'number')) {\n            throw new Error('JSON.stringify');\n        }\n\n// Make a fake root object containing our value under the key of ''.\n// Return the result of stringifying the value.\n\n        return str('', {'': value});\n    };\n\n    if (typeof JSON.stringify !== 'function') {\n        JSON.stringify = Faye.stringify;\n    }\n\n// If the JSON object does not yet have a parse method, give it one.\n\n    if (typeof JSON.parse !== 'function') {\n        JSON.parse = function (text, reviver) {\n\n// The parse method takes a text and an optional reviver function, and returns\n// a JavaScript value if the text is a valid JSON text.\n\n            var j;\n\n            function walk(holder, key) {\n\n// The walk method is used to recursively walk the resulting structure so\n// that modifications can be made.\n\n                var k, v, value = holder[key];\n                if (value && typeof value === 'object') {\n                    for (k in value) {\n                        if (Object.prototype.hasOwnProperty.call(value, k)) {\n                            v = walk(value, k);\n                            if (v !== undefined) {\n                                value[k] = v;\n                            } else {\n                                delete value[k];\n                            }\n                        }\n                    }\n                }\n                return reviver.call(holder, key, value);\n            }\n\n\n// Parsing happens in four stages. In the first stage, we replace certain\n// Unicode characters with escape sequences. JavaScript handles many characters\n// incorrectly, either silently deleting them, or treating them as line endings.\n\n            text = String(text);\n            cx.lastIndex = 0;\n            if (cx.test(text)) {\n                text = text.replace(cx, function (a) {\n                    return '\\\\u' +\n                        ('0000' + a.charCodeAt(0).toString(16)).slice(-4);\n                });\n            }\n\n// In the second stage, we run the text against regular expressions that look\n// for non-JSON patterns. We are especially concerned with '()' and 'new'\n// because they can cause invocation, and '=' because it can cause mutation.\n// But just to be safe, we want to reject all unexpected forms.\n\n// We split the second stage into 4 regexp operations in order to work around\n// crippling inefficiencies in IE's and Safari's regexp engines. First we\n// replace the JSON backslash pairs with '@' (a non-JSON character). Second, we\n// replace all simple value tokens with ']' characters. Third, we delete all\n// open brackets that follow a colon or comma or that begin the text. Finally,\n// we look to see that the remaining characters are only whitespace or ']' or\n// ',' or ':' or '{' or '}'. If that is so, then the text is safe for eval.\n\n            if (/^[\\],:{}\\s]*$/\n                    .test(text.replace(/\\\\(?:[\"\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@')\n                        .replace(/\"[^\"\\\\\\n\\r]*\"|true|false|null|-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g, ']')\n                        .replace(/(?:^|:|,)(?:\\s*\\[)+/g, ''))) {\n\n// In the third stage we use the eval function to compile the text into a\n// JavaScript structure. The '{' operator is subject to a syntactic ambiguity\n// in JavaScript: it can begin a block or an object literal. We wrap the text\n// in parens to eliminate the ambiguity.\n\n                j = eval('(' + text + ')');\n\n// In the optional fourth stage, we recursively walk the new structure, passing\n// each name/value pair to a reviver function for possible transformation.\n\n                return typeof reviver === 'function'\n                    ? walk({'': j}, '')\n                    : j;\n            }\n\n// If the text is not JSON parseable, then a SyntaxError is thrown.\n\n            throw new SyntaxError('JSON.parse');\n        };\n    }\n}());\n\nFaye.Transport.WebSocket = Faye.extend(Faye.Class(Faye.Transport, {\n  UNCONNECTED:  1,\n  CONNECTING:   2,\n  CONNECTED:    3,\n\n  batching:     false,\n\n  isUsable: function(callback, context) {\n    this.callback(function() { callback.call(context, true) });\n    this.errback(function() { callback.call(context, false) });\n    this.connect();\n  },\n\n  request: function(messages) {\n    this._pending = this._pending || new Faye.Set();\n    for (var i = 0, n = messages.length; i < n; i++) this._pending.add(messages[i]);\n\n    var promise = new Faye.Promise();\n\n    this.callback(function(socket) {\n      if (!socket || socket.readyState !== 1) return;\n      socket.send(Faye.toJSON(messages));\n      Faye.Promise.fulfill(promise, socket);\n    }, this);\n\n    this.connect();\n\n    return {\n      abort: function() { promise.then(function(ws) { ws.close() }) }\n    };\n  },\n\n  connect: function() {\n    if (Faye.Transport.WebSocket._unloaded) return;\n\n    this._state = this._state || this.UNCONNECTED;\n    if (this._state !== this.UNCONNECTED) return;\n    this._state = this.CONNECTING;\n\n    var socket = this._createSocket();\n    if (!socket) return this.setDeferredStatus('failed');\n\n    var self = this;\n\n    socket.onopen = function() {\n      if (socket.headers) self._storeCookies(socket.headers['set-cookie']);\n      self._socket = socket;\n      self._state = self.CONNECTED;\n      self._everConnected = true;\n      self._ping();\n      self.setDeferredStatus('succeeded', socket);\n    };\n\n    var closed = false;\n    socket.onclose = socket.onerror = function() {\n      if (closed) return;\n      closed = true;\n\n      var wasConnected = (self._state === self.CONNECTED);\n      socket.onopen = socket.onclose = socket.onerror = socket.onmessage = null;\n\n      delete self._socket;\n      self._state = self.UNCONNECTED;\n      self.removeTimeout('ping');\n      self.setDeferredStatus('unknown');\n\n      var pending = self._pending ? self._pending.toArray() : [];\n      delete self._pending;\n\n      if (wasConnected) {\n        self._handleError(pending, true);\n      } else if (self._everConnected) {\n        self._handleError(pending);\n      } else {\n        self.setDeferredStatus('failed');\n      }\n    };\n\n    socket.onmessage = function(event) {\n      var replies = JSON.parse(event.data);\n      if (!replies) return;\n\n      replies = [].concat(replies);\n\n      for (var i = 0, n = replies.length; i < n; i++) {\n        if (replies[i].successful === undefined) continue;\n        self._pending.remove(replies[i]);\n      }\n      self._receive(replies);\n    };\n  },\n\n  close: function() {\n    if (!this._socket) return;\n    this._socket.close();\n  },\n\n  _createSocket: function() {\n    var url        = Faye.Transport.WebSocket.getSocketUrl(this.endpoint),\n        headers    = this._dispatcher.headers,\n        extensions = this._dispatcher.wsExtensions,\n        cookie     = this._getCookies(),\n        tls        = this._dispatcher.tls,\n        options    = {extensions: extensions, headers: headers, proxy: this._proxy, tls: tls};\n\n    if (cookie !== '') options.headers['Cookie'] = cookie;\n\n    if (Faye.WebSocket)        return new Faye.WebSocket.Client(url, [], options);\n    if (Faye.ENV.MozWebSocket) return new MozWebSocket(url);\n    if (Faye.ENV.WebSocket)    return new WebSocket(url);\n  },\n\n  _ping: function() {\n    if (!this._socket) return;\n    this._socket.send('[]');\n    this.addTimeout('ping', this._dispatcher.timeout / 2, this._ping, this);\n  }\n\n}), {\n  PROTOCOLS: {\n    'http:':  'ws:',\n    'https:': 'wss:'\n  },\n\n  create: function(dispatcher, endpoint) {\n    var sockets = dispatcher.transports.websocket = dispatcher.transports.websocket || {};\n    sockets[endpoint.href] = sockets[endpoint.href] || new this(dispatcher, endpoint);\n    return sockets[endpoint.href];\n  },\n\n  getSocketUrl: function(endpoint) {\n    endpoint = Faye.copyObject(endpoint);\n    endpoint.protocol = this.PROTOCOLS[endpoint.protocol];\n    return Faye.URI.stringify(endpoint);\n  },\n\n  isUsable: function(dispatcher, endpoint, callback, context) {\n    this.create(dispatcher, endpoint).isUsable(callback, context);\n  }\n});\n\nFaye.extend(Faye.Transport.WebSocket.prototype, Faye.Deferrable);\nFaye.Transport.register('websocket', Faye.Transport.WebSocket);\n\nif (Faye.Event && Faye.ENV.onbeforeunload !== undefined)\n  Faye.Event.on(Faye.ENV, 'beforeunload', function() {\n    Faye.Transport.WebSocket._unloaded = true;\n  });\n\nFaye.Transport.EventSource = Faye.extend(Faye.Class(Faye.Transport, {\n  initialize: function(dispatcher, endpoint) {\n    Faye.Transport.prototype.initialize.call(this, dispatcher, endpoint);\n    if (!Faye.ENV.EventSource) return this.setDeferredStatus('failed');\n\n    this._xhr = new Faye.Transport.XHR(dispatcher, endpoint);\n\n    endpoint = Faye.copyObject(endpoint);\n    endpoint.pathname += '/' + dispatcher.clientId;\n\n    var socket = new EventSource(Faye.URI.stringify(endpoint)),\n        self   = this;\n\n    socket.onopen = function() {\n      self._everConnected = true;\n      self.setDeferredStatus('succeeded');\n    };\n\n    socket.onerror = function() {\n      if (self._everConnected) {\n        self._handleError([]);\n      } else {\n        self.setDeferredStatus('failed');\n        socket.close();\n      }\n    };\n\n    socket.onmessage = function(event) {\n      self._receive(JSON.parse(event.data));\n    };\n\n    this._socket = socket;\n  },\n\n  close: function() {\n    if (!this._socket) return;\n    this._socket.onopen = this._socket.onerror = this._socket.onmessage = null;\n    this._socket.close();\n    delete this._socket;\n  },\n\n  isUsable: function(callback, context) {\n    this.callback(function() { callback.call(context, true) });\n    this.errback(function() { callback.call(context, false) });\n  },\n\n  encode: function(messages) {\n    return this._xhr.encode(messages);\n  },\n\n  request: function(messages) {\n    return this._xhr.request(messages);\n  }\n\n}), {\n  isUsable: function(dispatcher, endpoint, callback, context) {\n    var id = dispatcher.clientId;\n    if (!id) return callback.call(context, false);\n\n    Faye.Transport.XHR.isUsable(dispatcher, endpoint, function(usable) {\n      if (!usable) return callback.call(context, false);\n      this.create(dispatcher, endpoint).isUsable(callback, context);\n    }, this);\n  },\n\n  create: function(dispatcher, endpoint) {\n    var sockets = dispatcher.transports.eventsource = dispatcher.transports.eventsource || {},\n        id      = dispatcher.clientId;\n\n    var url = Faye.copyObject(endpoint);\n    url.pathname += '/' + (id || '');\n    url = Faye.URI.stringify(url);\n\n    sockets[url] = sockets[url] || new this(dispatcher, endpoint);\n    return sockets[url];\n  }\n});\n\nFaye.extend(Faye.Transport.EventSource.prototype, Faye.Deferrable);\nFaye.Transport.register('eventsource', Faye.Transport.EventSource);\n\nFaye.Transport.XHR = Faye.extend(Faye.Class(Faye.Transport, {\n  encode: function(messages) {\n    return Faye.toJSON(messages);\n  },\n\n  request: function(messages) {\n    var href = this.endpoint.href,\n        xhr  = Faye.ENV.ActiveXObject ? new ActiveXObject('Microsoft.XMLHTTP') : new XMLHttpRequest(),\n        self = this;\n\n    xhr.open('POST', href, true);\n    xhr.setRequestHeader('Content-Type', 'application/json');\n    xhr.setRequestHeader('Pragma', 'no-cache');\n    xhr.setRequestHeader('X-Requested-With', 'XMLHttpRequest');\n\n    var headers = this._dispatcher.headers;\n    for (var key in headers) {\n      if (!headers.hasOwnProperty(key)) continue;\n      xhr.setRequestHeader(key, headers[key]);\n    }\n\n    var abort = function() { xhr.abort() };\n    if (Faye.ENV.onbeforeunload !== undefined) Faye.Event.on(Faye.ENV, 'beforeunload', abort);\n\n    xhr.onreadystatechange = function() {\n      if (!xhr || xhr.readyState !== 4) return;\n\n      var replies    = null,\n          status     = xhr.status,\n          text       = xhr.responseText,\n          successful = (status >= 200 && status < 300) || status === 304 || status === 1223;\n\n      if (Faye.ENV.onbeforeunload !== undefined) Faye.Event.detach(Faye.ENV, 'beforeunload', abort);\n      xhr.onreadystatechange = function() {};\n      xhr = null;\n\n      if (!successful) return self._handleError(messages);\n\n      try {\n        replies = JSON.parse(text);\n      } catch (e) {}\n\n      if (replies)\n        self._receive(replies);\n      else\n        self._handleError(messages);\n    };\n\n    xhr.send(this.encode(messages));\n    return xhr;\n  }\n}), {\n  isUsable: function(dispatcher, endpoint, callback, context) {\n    callback.call(context, Faye.URI.isSameOrigin(endpoint));\n  }\n});\n\nFaye.Transport.register('long-polling', Faye.Transport.XHR);\n\nFaye.Transport.CORS = Faye.extend(Faye.Class(Faye.Transport, {\n  encode: function(messages) {\n    return 'message=' + encodeURIComponent(Faye.toJSON(messages));\n  },\n\n  request: function(messages) {\n    var xhrClass = Faye.ENV.XDomainRequest ? XDomainRequest : XMLHttpRequest,\n        xhr      = new xhrClass(),\n        id       = ++Faye.Transport.CORS._id,\n        headers  = this._dispatcher.headers,\n        self     = this,\n        key;\n\n    xhr.open('POST', Faye.URI.stringify(this.endpoint), true);\n\n    if (xhr.setRequestHeader) {\n      xhr.setRequestHeader('Pragma', 'no-cache');\n      for (key in headers) {\n        if (!headers.hasOwnProperty(key)) continue;\n        xhr.setRequestHeader(key, headers[key]);\n      }\n    }\n\n    var cleanUp = function() {\n      if (!xhr) return false;\n      Faye.Transport.CORS._pending.remove(id);\n      xhr.onload = xhr.onerror = xhr.ontimeout = xhr.onprogress = null;\n      xhr = null;\n    };\n\n    xhr.onload = function() {\n      var replies = null;\n      try {\n        replies = JSON.parse(xhr.responseText);\n      } catch (e) {}\n\n      cleanUp();\n\n      if (replies)\n        self._receive(replies);\n      else\n        self._handleError(messages);\n    };\n\n    xhr.onerror = xhr.ontimeout = function() {\n      cleanUp();\n      self._handleError(messages);\n    };\n\n    xhr.onprogress = function() {};\n\n    if (xhrClass === Faye.ENV.XDomainRequest)\n      Faye.Transport.CORS._pending.add({id: id, xhr: xhr});\n\n    xhr.send(this.encode(messages));\n    return xhr;\n  }\n}), {\n  _id:      0,\n  _pending: new Faye.Set(),\n\n  isUsable: function(dispatcher, endpoint, callback, context) {\n    if (Faye.URI.isSameOrigin(endpoint))\n      return callback.call(context, false);\n\n    if (Faye.ENV.XDomainRequest)\n      return callback.call(context, endpoint.protocol === Faye.ENV.location.protocol);\n\n    if (Faye.ENV.XMLHttpRequest) {\n      var xhr = new Faye.ENV.XMLHttpRequest();\n      return callback.call(context, xhr.withCredentials !== undefined);\n    }\n    return callback.call(context, false);\n  }\n});\n\nFaye.Transport.register('cross-origin-long-polling', Faye.Transport.CORS);\n\nFaye.Transport.JSONP = Faye.extend(Faye.Class(Faye.Transport, {\n encode: function(messages) {\n    var url = Faye.copyObject(this.endpoint);\n    url.query.message = Faye.toJSON(messages);\n    url.query.jsonp   = '__jsonp' + Faye.Transport.JSONP._cbCount + '__';\n    return Faye.URI.stringify(url);\n  },\n\n  request: function(messages) {\n    var head         = document.getElementsByTagName('head')[0],\n        script       = document.createElement('script'),\n        callbackName = Faye.Transport.JSONP.getCallbackName(),\n        endpoint     = Faye.copyObject(this.endpoint),\n        self         = this;\n\n    endpoint.query.message = Faye.toJSON(messages);\n    endpoint.query.jsonp   = callbackName;\n\n    var cleanup = function() {\n      if (!Faye.ENV[callbackName]) return false;\n      Faye.ENV[callbackName] = undefined;\n      try { delete Faye.ENV[callbackName] } catch (e) {}\n      script.parentNode.removeChild(script);\n    };\n\n    Faye.ENV[callbackName] = function(replies) {\n      cleanup();\n      self._receive(replies);\n    };\n\n    script.type = 'text/javascript';\n    script.src  = Faye.URI.stringify(endpoint);\n    head.appendChild(script);\n\n    script.onerror = function() {\n      cleanup();\n      self._handleError(messages);\n    };\n\n    return {abort: cleanup};\n  }\n}), {\n  _cbCount: 0,\n\n  getCallbackName: function() {\n    this._cbCount += 1;\n    return '__jsonp' + this._cbCount + '__';\n  },\n\n  isUsable: function(dispatcher, endpoint, callback, context) {\n    callback.call(context, true);\n  }\n});\n\nFaye.Transport.register('callback-polling', Faye.Transport.JSONP);\n\n})();"],"sourceRoot":"/source/"}